current page: 140

WSO2 Data Service Server = exposes data from different resources

WSO2 Message Broker = uses the publish/subscribe model to send messages to different parts

WSO2 Business Process Server = bussiness process engine, stands for higher level of abstraction called BPM (Bussiness Process Management)
which stands for discover, model, analyze, measure, improve and optimize business strategy and processes.

WSO2 has also the UDDI registry called WSO2 Governance Registry, 

WSO2 Application Server is a Java application container for web applications also called Carbon Platform

UDDI is often compared to a telephone book's white, yellow, and green pages. The project allows businesses to list themselves by name, product, location, or the Web services they offer. Microsoft, IBM, and Ariba spearheaded UDDI. The project now includes 130 companies,

the latest component called WSO2 EI 6 is an all encompasing version of WSO2 in which all the services are encapsulated in this.

Wso2 Update Manage is preferred way to update and install applications, can be done manually too

WSO2 EI consists of:

- WSO2 ESB
- WSO2 DataService Server
- WSO2 Application Server
- WSO2 Analytics
- WSO2 Business PRocess
- WSO2 Message Broker

in here the first three are combined in one group also called WSO2 EI

- to make use of EI you need to install the java jdk environment variable to the bin

- WUM is the Wso2 Update Manager which allows you to update and install apps, now depricated and replaced by WSO2 updater 2.0

- to start the EI you should go to <WSO2EI_Home>/bin this is the installation folder  C:\Program Files\WSO2\EnterpriseIntegrator\6.6.0\  and execute the following commands
on linux sh integrator.sh
on windows integrator.bat --run

- Management Console URL = https://192.168.0.163:8243/carbon for people which want to access it from the internet, from the host of the Enterprise Integrator it should be differen it should be localhost dependant on the version e.g:

WSO2 EI 6.0.0 : https://localhost:8243/carbon

WSO2 EI 6.1.0 : https://localhost:9443/carbon

EI has a standard certificate for the https request which is not signed yet but good enough for test purposes

the default username and password are : admin

to stop the EI do the following:

- windows: type ctrl+C

- linux sh integrator.sh stop

- to start analytics go in the command prompt to <EI_HOME>/wso2/analytics/bin

- type in sh integrator.sh or integrator.bat --run dependant on the environment

- same thing with the url but with a different port e.g: https://localhost:9444/carbon

- sign in with the admin credentials

- closing is the same way as with the EI

- for the WSO2 EI Business Process you need to start it by going with the command prompt to 
<EI_HOME>/wso2/business-process/bin

- the starting command differs as this is sh.wso2server.sh on linux and wso2server.bat for windows

- the port differs for this program as this is https://localhost:9445/carbon

- sign in with the admin credentials

- to start the WSO2 Broker go to  <EI_HOME>/wso2/broker/bin in the console

- to start the server run the commands sh.wso2server.sh for linux
and wso2server.bat for 

- the url https://localhost:9446/carbon is the general url you will get

- to close you can type ctrl c for windows or sh wso2server.sh from the given location

- to start all four components go via the command prompt to <EI_HOME>/bin directory
type in the following for Linux shstart-all.sh and for windows shooce start-all.bat
all the processes will have  a 10 second gap inbetween the starting of it

- transports are like enabling to process files or send mails,
we can enable these transports in the axis2.xml file which recides in <EI_HOME>/conf/axis2/axis2.xml
the input transports are transportReciever XML tag while the output transports are named transportSender

-Message formatters and Message builders allow us to send and recieve different types of messages
the Message builder is meant to process incoming messages
and the message formatter are used to build outgoing messages
we can change the settings in the axis2 file, most configurations are already given but commented out
it may look like this 
<messageformatter contenttype="application/json" class="org.apache.axis2.json.JSONMessageFormatter"></messageformatter>

- projects are also called carbon projects

- the following three have all their own project structure, called ESB enterprise Service Bys,DSS Data Services and BPS Business Process Server

most used projects are:
- ESBConfig = has all the artifacts related to the functionality of an ESB
- Registry Resource Project = contains XSLT's WSLD ,XSD and and more
- Data Service Project = needed when data needs to be stored and analyzed
- Composite application project = this genereates the deployable artifacts, it allows you to select which artifacts would get added to the composite application Project that will be deployed
- ESB Solution Project = wizard allows to create commmon projects 

when a new ESb projects is created you can choose to choose the next artifacts.
- Proxy service = this is to create any service different from the REST services like SOAP and JMS(Java Message Serice)
- REST API: to create REST API's
- Sequences: allow us to structure service flow in little pieces so the code will be more readable
- Endpoints: the destination we can send messages to

- when creating aproxy you can fill in the name and types as following:
- Pass Trough Proxy: the service sends information to the endpoint without any processing, has a generic WSDL
- Custom Proxy:choose this if all the other templates do not coincide
- transform Proxy: transforms message to XSL(Extensible Stylesheet Language), can be done during income flow or prior to sending to the backend
-Log Forward Proxy: same as pass trough proxy but with the option to log the message sent and recieved
- WSDL Based Proxy: like pass trough proxy but it allows you to set the WSDL for it 
- Secure Proxy: like pass trough proxy but with the ability to secure it using a secure policy

- a proxy has three parts:
 - in flow sequence = we place logic that processes incoming messages
 - out flow sequence = logic for outcoming messages, these are the responses recieved from an endpoint
 - Fault flow sequence - Here, we implement the behavior that would be triggered during the flow

 - when creating a REST API you have the next options:
  - name = naming of the API
  - Context = root context e.g nnv will be http://localhost:8280/nnv, it must start with /
  - Host name = filters host which can invoke the API, when empty everyone can use it
  - Save location: choose the ESBPRoject in which it is stored

- REST API's have the same structure as proxyies, as they have in, out and fault sequences

- To Create a Sqeuence you can click on the Sequence map and create it
the mandatory options are the name and project to save in

- the advanced options exist of:
 - Error Sequence = shows which sequence should be executed during an error, if not chosen the proxy which uses this sequence will be executed
 - Available Endpoints = select a default endpoint to send the message.
 - Dynamix sequence, this option allows the sequence will be stored in the registry, which of two locations are possible, the Configuration and Governance map
configuration are shared by all WSO2 nodes in a cluster and the governance aer shared by all wso2 products of our environment

when creating an endpoint you have the option to fill in the following
- name = name
- type = type of endpoint choses, mostly used is the Address Endpoint
- static vs dynamic= dynamic stores endpoint in the registry
- save = where to save

- Registry Resource = provides useful functionality scuh as message validation or XSL transformation
- WSDL and XML Schema Definition files require the proxy WSDL to be uploaded to the registry

- when adding a new resource we have multiple options:
 - from existing template: this helps us to create a resource starting from a WSDL or XSD template
 - import from the system: this is for when you have the resource already or given
 - Import registry dump file from file system: this will load package with the registry content, only when you don't have e.g: acces to the product registry
 - Check-out from registry : this option allows you to connect the registry over which you will run your service so that you can work with the target directly

 - when adding a resource from an existing template you must follow the following
  - Resource Name: Name
  - Templates: most commonly used are WSDL,XSD and XSL
  - Registry: choose gov or conf 
  - Registry path: here we type the path
  - save resource in: here we hoose a Registry project to save the resources in

 - when import from file system is chosen:
  - the given options are the next:
  - from file: here we can browse to a file or folder
  - Artifact name: Name
  - Registry: choose conf or gov
  - Registry path to deploy: folder where the resource will be located
  - Save resource in: here we choose the Registry Project where we add the resources


- Data Service Project allows you to talk to multiple data sources
to create it click on Data Service PRoject at the starting page and fill in all the necessary information 
- Data Service Name: name
- Data Service Group: can be left blank, is used for grouping data services
- Data Service Namespace: Namespace
- Description: Description
- Save Data Service in : where to store data service
- click next
- Data Source Id: the name
- Data Source Type: most used is Carbon Data Source
- Data Source Name: name of the data source

- Composite Application Project will used to generate deployable artifacts, can check which artifacts inside the same workspace to combine into the Carbon Application aRchive (CAR)

- double click on pom.xml to check the artifacts which you want to deploy

- under the dependencies bar you can choose the server role, default is Governance Registry when governance registry is not used set the role as EnterpriseServiceBus

- the car file can be deployed to the server by opening WSO2EI managament console/dashboard go to Main under Carbon Applications add the car file inside the console you can see if it was succesfull or not


- when creating an ESB Solution Project you have the choice of the following projects to be created at once
 - ESBConfig Project (required)
 - Registry Resource Project (Optional)
 - Composite Application Project (Optional)
 - Connector Exporter Project (Optional)

to start the WSO2EI in debug mode you should start the service trough the following command integrator.bat --run -Desb.debug=true for windows
and shintegrator.sh -Desb.debug=true

- breakpoint can be set at each mediator where to pause the application

- Message envelope shows all the raw envelope data

- variables window shows all variable values

- Data Mapping can be done trough multiple generally used integration patterns like, it involves converting, trabslating and transforming data from one data format to another:
 - Message Translator = change input to other output
 - Normalizer = router sending multiple source incomes to the right translator depending on the source
 - Canonical Data Model = create a data model which is a superset of all others and create a translator layer after it

the Data Mapper Mediator uses the next three things:
 - Input Schema File: XML or JSON Input file
 - Output Schema file
 - Mapping configuration file: Javascript file that has information about how the translation takes place

double click on your DataMapper Mediator and create new project
- in Load Input choose input type and the file to load in
- right click on output box and choose add new root
- right click on response and click on addfield, type should be string name should be yousay
- follow the image as following
- image 1.png

there are multiple entrypoints which exist of the following:
- proxy acts as a virtual service recieves messages and mediates them before sending them to the endpoint
- Main sequence default sequence for all messages not sent to a proxy service
- API uses REST
- Inbound Endpoint: a message source that can be configured manually
- Task: scheduled jobs to execute proxy service or a named sequence

when we create a service it's necessary to configure the following:
- Transport: Carry the payload in a specific format
- Mediators: message processing units
- Sequences: List of Mediators executed Sequentially
- Endpoints:Define distonation for current payload

a property is a variable that stores some information during a time that depends on the scope it has configured
written as 
<property name="string" [action=set|remove] [type="string"] value="literal">
 <xml-element/>?
</property>

there are three different types of properties:
 - static:
   <property name="color" value="red" />
 - Dynamic:
  from an xpath expression:
   <property name="dynamic1" expression="//xpath"/>
  from any other property:
   <property name="dynamic2" expression="get-property('dynamic1')"/>
  - Action:
   <property name="To" action="remove"/>

   these properties can have seven different scopes:
   - Axis2: shortest scope and is only used to send parameters to Axis2 engine
   - Synapse: The property will live in the same sequence; it's the default scope
   - Axis-client: same duration as synapse, but the property can be read trough custom Mediators
   - Operation: it's the largest scope; the property will live until the end of the service trough the different sequences
   - Registry: used to get properties from the registry
   - System: get Java system properties
   - Transport: the property will be sent as a transport header

   Logging a property is done as follows:
    <log [level="string"] [seperator="string"]>
     <property name="string" (value="literal" | expression="[XPath|json-eval(JSON Path)]")/>
     </log>

     There are six Categories of logging:
     - TRACE
     - DEBUG
     - INFO
     - WARN
     - ERROR
     - FATAL

     there also four levels of logging:

     - Custom: Show the properties configured inside the element
     - Full: shows the Show To, From, WSAction, SOAPAction, ReplyTo, and MEssageID headers and the current payload
     - headers: Log all the SOAP headers
     - Simple: Log To, From, WSAction, SOAPActionm ReplyTo and MessageID headers

     by default the log is placed at <WSO2_HOME>/repository/log/wso2carbon.log

     - there are multiple types of send mediators, when in the out sequence it will call the calling client 
     - when the <send/> mediator is used with not further information it will use the given implicit endpoint
     - inline definition is as shown
     <send>
      <endpoint>
       <address uri="http://localhost:8280/services/"
      </endpoint>
     </send>
     - with a named endpoint is shown below
     <send recieve="OutSequence">
      <endpoint key="CreditEPR"/>
     </send>

     The Respond mediator stops the current message and sends the payload back to the requesting client
     written as 
     <respond/>

     The loopback mediator moves the current message to the out sequence
     written as
     <loopback/>

     The Drop Mediator stops processing the current message, only when configured inside the sequence sends an HTTP 202 accepted response to the client
     written as
     <drop/>

     The Sequence mediator throws the processing of the named sequence or registry sequence
     named sequence goes as the following:
     <sequence key="namedSequence"/>
     the registry sequence syntax is as follows:
     <sequence key="conf:/path/to/registrySequence"/>

     The script Mediator can use different scripting languages such as Javascript, Groovy and Ruby
     inline script syntax starts as the following
     <script language="js">
     <![CDATA[
      //script code
     ]]
     <script/>

     registry script syntax starts as the following:
     <script key="path/to/script" language="(js | groovy | rb) [function="nameOfTheFunction"]">
      [<include key="string">]
     <script/>

     a sequence is triggered when there is no available axis2 services
     
     you can filter the incoming messages as the following

     <filter regex="http://localhost:9000.*" source="get- property('To')">
     <then>
     </then>
     <else>
     <else/>
     </filter>

     the fault and in and out sequence are the generic options, it also is possible to create custom sequences by doing the following

     <sequence name="string" [onError="string"][key="string"][trace="enable"][statistics="enable"]></sequence>

     Onerror attribute sets the sequence that will be triggered when there's a problem during the processing of the seuence, instead of the default sequence

     statistics to anble statistics collection which tracks number of messages proccesed and their processing times

     trace enable trace collection in which the message will write ttracing information trough each mediation step

     the transformer proxy recieves the request and then applies a transformation using the XSLT language before sending it to the backend service, it can also
     change the backend response before sending it back to the client

     a secure proxy applies the WS-Security Standard security on a non scure backend to mae it more secure

     WSDL Based proxy is used when you already have the wsdl

     Logging Proxy is similar to a pass trough proxy but it also has the ability to log all incoming and outgoing requests

     simple proxy only gets the message and forwards it to the backend

     custom proxies are for when there is need for a more complex type of proxie which doesn't fall in the previous Categories
     you have to configure the in out and fault sequence the endpoints, transport etc.

     API's are used as REST instead os SOAP, API's are simpler to develop and have better performance and scalability

     <api name="API_NAME" context="URI_PATH_OF_API" [hostname="HOST_NAME_OF_SERVER][port="PORT"]>
      <resource [methods="GET|POST|PUT|DELETE|OPTIONS|HEAD|PATCH"] [uri-template="URI_TEMPLATE"|url-mapping="URL_MAPPING"]/>
    
    you either choose the uri-template or url-mapping as your standard

    when choosing a url mapping you have three types of patterns you can choose e.g:
    - Path Mapping: all the paths which start with: /resource/*
    - Extension mappings: only the requests starting with the extensions will be listened to:  *.jag
    - Exact mappings: only the requests with the exact mapping will be listened too: /resource

    to read the incoming parameters you can use the following:
    - POST: json-eval($.nameParameter)
    - GET: $ctx:query.param.nameParameter

    example is:
    <api context=/urlmappingapi>
    <resource methods="GET" url-mapping="/getParam">
    <InSequence>
    <property name="Value of GET param" expression="$ctx:query.param.param"/>
    <InSequence/>
    <resource/>

    input = http://localhost:8280/urlmappingapi/getParam?param-getParam

    <api context=/urlmappingapi>
    <resource methods="POST" url-mapping="/postParam"
    <inSequence>
     <property name="Value of POSt param" expression="json-eval($.param)">
    </inSequence>

    input =
    curl -H "Content-Type: application/json" -X POST
    -d {"param":"postParam"}
    http://localhost:8280/urlmappingapi/postParam 

    with URI Templates we can assign the variables trough the url like: /resource/{param1}/{param2}

    to read the variables you should use the get-property('uri.var.nameParameter')

    the next code will take either GET or POST

    <api name="UriTemplateAPI" context="/uritemplateapi">
     <resource methods="POST GET" uri-template = "/resource/{param1}/{param2}">
     <inSequence>
     <property name="Value of param1" expression="get-property('uri.var.param1')/">
     <property name="Value of param2" expression="get-property('uri.var.param2')"/>
     </inSequence>     
     </resource>
    </api>

    this can be done trough either a: 
    GET : curl http://localhost:8280/uritemplateapi/resource/P1/param2

    or

    POST : curl -X POST http://localhost:8280/uritemplateapi/resource/P1/param2

    you have besides the API and Proxies another service which is called the inbound endpoint,
    this skips the axis2 layer and gets directly from the transport layer to the mediation layer,
    this leads to not having to reboot the server on every change there are four types of inbound endpoints e.g:
    - Listening
    - Polling
    - Event-Based
    - Custom

    LISTENING
    ===========================

    Inbound Endpoints have different types of protocols such as HTTP,HTTPS,HL7,CXD Websocket and Secure Websocket

    the basic configuration of the inbound endpoint you need the following:
    - Endpoint Name
    - Type
    - Sequence: the sequence which will be processed on an incoming request
    - inbound.http.port: port that will open dynamically for the listen request

    for testing we need to make a request to that port as given: curl http://localhost:8765

    POLLING
    ==============================
    this type of inbound endpoints continously polls for data at a given interval time, when data is available will this data trigger a specific sequence
    with the data as a payload

    there are three different polling types:

    - File: for FTP,SFTP and FILE connections
    - JMS: Java Message Service protocols
    - Kafka: for Apache Kafka protocols

    to test it you can add a file that directs to the url in the given parameter called pollinginboundendpoint.txt in C:\Temp

    EVENT 
    ==============================
    event based inbound endpoint will establish the connection with the configure server when it's created and then stay waiting for a specific configured event

    out of the box you have Message Queue Telemetry Transport called MQTT and RabbitMQ protocols

    the given image settings will trigger the main sequence when recieving an event on the set localhost port

    image 2.png

    CUSTOM
    =============================
    when the previously given inbound endpoints are not enough you can create your own custom , here you need to create a java class with all the logic and 
    the specific inbound type.

    =============================

    With Tasks we can setup up the execution of a service to be processed on a specific date and time, for a specified number of times

    You can find it under Main | Manage | Services | Add | Data Service | Scheduled Task

    you will have some general options to fill in with two options for scheduling type: Data Service Operation for invoking an existing data service Operation
    and Data Service Task Class for invoking a custom task class  


    there are also sheduled Tasks at Main | Manage | Service Bus | Scheduled Tasks

    this one allows us to create tasks for launch proxy, sequences, endpoints, and so once

    we can schedule tasks in three different ways

    1. specifying the number of times and the interval to launch the process
    2. setting up a cron expression
    3. design a task that will only be executed once the server starts

    there are multiple parameters which you can fill in like:
    - Task implementation: java class implementation default is org.apache.synapse.startup.tasks.MessageInjector
    - Registry Key: PAth in the registry to execute the task
    - Inject To: specify if its a proxy or sequence
    - Trigger Type:
     - Simple: specify count and interval
     - Cron: specify the cron expression
    - Pinned Servers: List of servers to launch the task


    DataService can be built using the WSO2 EI management console not advisable for production environment,
    you have two choices the Generate Wizard which automaticly creates a data serivce with the CRUD operation required to manage one or several tables
    or the creatre wizard in which you customize every step's configuration

    or you can use the WSO2 EI Tooling, this is the advised way to do it, here you are allowed to generate carbon files for the deliveries,  as well as manage your
    code in the github repository

    The management console enables you to quickly perform modification as well as test them which is  a pro of using it 
    
    WSO2 EI allows you to create the following data sources such as Relational Database Management System (RBDMS most used one) CSV, EXCEL, ODS, Cassandra, Google Spreadsheets, RDF,
    and any web page.

    go to Configure | DataSources and click on Add DataSource after that

    here you get multiple parameters to choose from one of which is the URL which is the adress to connect to the database
     one example is jdbc:mysql://localhost:3306/wso2ei

    You can define custom data sources using XML and place them in $EI_HOME/conf/datasources

    The Create wizard can be found in the Management Console under Main | Data Service | Create

    when you created a new datasource you get the option to add a new query, do this
    inside the SQL box type in the Data Manipulation Language (DML)
    type in the following SQL statement to get all the records
    SELECT ID, Name, CountryCode, District, Population FROM city

    the xml output and input could be autogenerated

    when using JSON you should change the WSO2_EI/conf/axis/axis2.xml and WSO2_EI/conf/axis/axis_client.xml must containerthe next
    <parameter name="httpContentNegotiation">true</parameter>

    JSON has no ability to autogenerate the output and input this has to be done manually

    this will result in the next

    {
      "Cities":{
        "City":[
          {
            "CityID": "$1",
            "CityName": "$2",
            "CountryCode": "$3",
            "District": "$4",
            "Population": "$5"
          }
        ]
      }
    }

    when using input parameters the input autogeneration tool won't work this should be dobe manually, the output works fine, when using
    input variable use the variable name with the : symbol before it like this
    SELECT ID, Name, CountryCode, District, Population FROM city WHERE CountryCode = :countryCode AND population < :population