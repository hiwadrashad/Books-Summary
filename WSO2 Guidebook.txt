current page: 248

WSO2 Data Service Server = exposes data from different resources

WSO2 Message Broker = uses the publish/subscribe model to send messages to different parts

WSO2 Business Process Server = bussiness process engine, stands for higher level of abstraction called BPM (Bussiness Process Management)
which stands for discover, model, analyze, measure, improve and optimize business strategy and processes.

WSO2 has also the UDDI registry called WSO2 Governance Registry, 

WSO2 Application Server is a Java application container for web applications also called Carbon Platform

UDDI is often compared to a telephone book's white, yellow, and green pages. The project allows businesses to list themselves by name, product, location, or the Web services they offer. Microsoft, IBM, and Ariba spearheaded UDDI. The project now includes 130 companies,

the latest component called WSO2 EI 6 is an all encompasing version of WSO2 in which all the services are encapsulated in this.

Wso2 Update Manage is preferred way to update and install applications, can be done manually too

WSO2 EI consists of:

- WSO2 ESB
- WSO2 DataService Server
- WSO2 Application Server
- WSO2 Analytics
- WSO2 Business PRocess
- WSO2 Message Broker

in here the first three are combined in one group also called WSO2 EI

- to make use of EI you need to install the java jdk environment variable to the bin

- WUM is the Wso2 Update Manager which allows you to update and install apps, now depricated and replaced by WSO2 updater 2.0

- to start the EI you should go to <WSO2EI_Home>/bin this is the installation folder  C:\Program Files\WSO2\EnterpriseIntegrator\6.6.0\  and execute the following commands
on linux sh integrator.sh
on windows integrator.bat --run

- Management Console URL = https://192.168.0.163:8243/carbon for people which want to access it from the internet, from the host of the Enterprise Integrator it should be differen it should be localhost dependant on the version e.g:

WSO2 EI 6.0.0 : https://localhost:8243/carbon

WSO2 EI 6.1.0 : https://localhost:9443/carbon

EI has a standard certificate for the https request which is not signed yet but good enough for test purposes

the default username and password are : admin

to stop the EI do the following:

- windows: type ctrl+C

- linux sh integrator.sh stop

- to start analytics go in the command prompt to <EI_HOME>/wso2/analytics/bin

- type in sh integrator.sh or integrator.bat --run dependant on the environment

- same thing with the url but with a different port e.g: https://localhost:9444/carbon

- sign in with the admin credentials

- closing is the same way as with the EI

- for the WSO2 EI Business Process you need to start it by going with the command prompt to 
<EI_HOME>/wso2/business-process/bin

- the starting command differs as this is sh.wso2server.sh on linux and wso2server.bat for windows

- the port differs for this program as this is https://localhost:9445/carbon

- sign in with the admin credentials

- to start the WSO2 Broker go to  <EI_HOME>/wso2/broker/bin in the console

- to start the server run the commands sh.wso2server.sh for linux
and wso2server.bat for 

- the url https://localhost:9446/carbon is the general url you will get

- to close you can type ctrl c for windows or sh wso2server.sh from the given location

- to start all four components go via the command prompt to <EI_HOME>/bin directory
type in the following for Linux shstart-all.sh and for windows shooce start-all.bat
all the processes will have  a 10 second gap inbetween the starting of it

- transports are like enabling to process files or send mails,
we can enable these transports in the axis2.xml file which recides in <EI_HOME>/conf/axis2/axis2.xml
the input transports are transportReciever XML tag while the output transports are named transportSender

-Message formatters and Message builders allow us to send and recieve different types of messages
the Message builder is meant to process incoming messages
and the message formatter are used to build outgoing messages
we can change the settings in the axis2 file, most configurations are already given but commented out
it may look like this 
<messageformatter contenttype="application/json" class="org.apache.axis2.json.JSONMessageFormatter"></messageformatter>

- projects are also called carbon projects

- the following three have all their own project structure, called ESB enterprise Service Bys,DSS Data Services and BPS Business Process Server

most used projects are:
- ESBConfig = has all the artifacts related to the functionality of an ESB
- Registry Resource Project = contains XSLT's WSLD ,XSD and and more
- Data Service Project = needed when data needs to be stored and analyzed
- Composite application project = this genereates the deployable artifacts, it allows you to select which artifacts would get added to the composite application Project that will be deployed
- ESB Solution Project = wizard allows to create commmon projects 

when a new ESb projects is created you can choose to choose the next artifacts.
- Proxy service = this is to create any service different from the REST services like SOAP and JMS(Java Message Serice)
- REST API: to create REST API's
- Sequences: allow us to structure service flow in little pieces so the code will be more readable
- Endpoints: the destination we can send messages to

- when creating aproxy you can fill in the name and types as following:
- Pass Trough Proxy: the service sends information to the endpoint without any processing, has a generic WSDL
- Custom Proxy:choose this if all the other templates do not coincide
- transform Proxy: transforms message to XSL(Extensible Stylesheet Language), can be done during income flow or prior to sending to the backend
-Log Forward Proxy: same as pass trough proxy but with the option to log the message sent and recieved
- WSDL Based Proxy: like pass trough proxy but it allows you to set the WSDL for it 
- Secure Proxy: like pass trough proxy but with the ability to secure it using a secure policy

- a proxy has three parts:
 - in flow sequence = we place logic that processes incoming messages
 - out flow sequence = logic for outcoming messages, these are the responses recieved from an endpoint
 - Fault flow sequence - Here, we implement the behavior that would be triggered during the flow

 - when creating a REST API you have the next options:
  - name = naming of the API
  - Context = root context e.g nnv will be http://localhost:8280/nnv, it must start with /
  - Host name = filters host which can invoke the API, when empty everyone can use it
  - Save location: choose the ESBPRoject in which it is stored

- REST API's have the same structure as proxyies, as they have in, out and fault sequences

- To Create a Sqeuence you can click on the Sequence map and create it
the mandatory options are the name and project to save in

- the advanced options exist of:
 - Error Sequence = shows which sequence should be executed during an error, if not chosen the proxy which uses this sequence will be executed
 - Available Endpoints = select a default endpoint to send the message.
 - Dynamix sequence, this option allows the sequence will be stored in the registry, which of two locations are possible, the Configuration and Governance map
configuration are shared by all WSO2 nodes in a cluster and the governance aer shared by all wso2 products of our environment

when creating an endpoint you have the option to fill in the following
- name = name
- type = type of endpoint choses, mostly used is the Address Endpoint
- static vs dynamic= dynamic stores endpoint in the registry
- save = where to save

- Registry Resource = provides useful functionality scuh as message validation or XSL transformation
- WSDL and XML Schema Definition files require the proxy WSDL to be uploaded to the registry

- when adding a new resource we have multiple options:
 - from existing template: this helps us to create a resource starting from a WSDL or XSD template
 - import from the system: this is for when you have the resource already or given
 - Import registry dump file from file system: this will load package with the registry content, only when you don't have e.g: acces to the product registry
 - Check-out from registry : this option allows you to connect the registry over which you will run your service so that you can work with the target directly

 - when adding a resource from an existing template you must follow the following
  - Resource Name: Name
  - Templates: most commonly used are WSDL,XSD and XSL
  - Registry: choose gov or conf 
  - Registry path: here we type the path
  - save resource in: here we hoose a Registry project to save the resources in

 - when import from file system is chosen:
  - the given options are the next:
  - from file: here we can browse to a file or folder
  - Artifact name: Name
  - Registry: choose conf or gov
  - Registry path to deploy: folder where the resource will be located
  - Save resource in: here we choose the Registry Project where we add the resources


- Data Service Project allows you to talk to multiple data sources
to create it click on Data Service PRoject at the starting page and fill in all the necessary information 
- Data Service Name: name
- Data Service Group: can be left blank, is used for grouping data services
- Data Service Namespace: Namespace
- Description: Description
- Save Data Service in : where to store data service
- click next
- Data Source Id: the name
- Data Source Type: most used is Carbon Data Source
- Data Source Name: name of the data source

- Composite Application Project will used to generate deployable artifacts, can check which artifacts inside the same workspace to combine into the Carbon Application aRchive (CAR)

- double click on pom.xml to check the artifacts which you want to deploy

- under the dependencies bar you can choose the server role, default is Governance Registry when governance registry is not used set the role as EnterpriseServiceBus

- the car file can be deployed to the server by opening WSO2EI managament console/dashboard go to Main under Carbon Applications add the car file inside the console you can see if it was succesfull or not


- when creating an ESB Solution Project you have the choice of the following projects to be created at once
 - ESBConfig Project (required)
 - Registry Resource Project (Optional)
 - Composite Application Project (Optional)
 - Connector Exporter Project (Optional)

to start the WSO2EI in debug mode you should start the service trough the following command integrator.bat --run -Desb.debug=true for windows
and shintegrator.sh -Desb.debug=true

- breakpoint can be set at each mediator where to pause the application

- Message envelope shows all the raw envelope data

- variables window shows all variable values

- Data Mapping can be done trough multiple generally used integration patterns like, it involves converting, trabslating and transforming data from one data format to another:
 - Message Translator = change input to other output
 - Normalizer = router sending multiple source incomes to the right translator depending on the source
 - Canonical Data Model = create a data model which is a superset of all others and create a translator layer after it

the Data Mapper Mediator uses the next three things:
 - Input Schema File: XML or JSON Input file
 - Output Schema file
 - Mapping configuration file: Javascript file that has information about how the translation takes place

double click on your DataMapper Mediator and create new project
- in Load Input choose input type and the file to load in
- right click on output box and choose add new root
- right click on response and click on addfield, type should be string name should be yousay
- follow the image as following
- image 1.png

there are multiple entrypoints which exist of the following:
- proxy acts as a virtual service recieves messages and mediates them before sending them to the endpoint
- Main sequence default sequence for all messages not sent to a proxy service
- API uses REST
- Inbound Endpoint: a message source that can be configured manually
- Task: scheduled jobs to execute proxy service or a named sequence

when we create a service it's necessary to configure the following:
- Transport: Carry the payload in a specific format
- Mediators: message processing units
- Sequences: List of Mediators executed Sequentially
- Endpoints:Define distonation for current payload

a property is a variable that stores some information during a time that depends on the scope it has configured
written as 
<property name="string" [action=set|remove] [type="string"] value="literal">
 <xml-element/>?
</property>

there are three different types of properties:
 - static:
   <property name="color" value="red" />
 - Dynamic:
  from an xpath expression:
   <property name="dynamic1" expression="//xpath"/>
  from any other property:
   <property name="dynamic2" expression="get-property('dynamic1')"/>
  - Action:
   <property name="To" action="remove"/>

   these properties can have seven different scopes:
   - Axis2: shortest scope and is only used to send parameters to Axis2 engine
   - Synapse: The property will live in the same sequence; it's the default scope
   - Axis-client: same duration as synapse, but the property can be read trough custom Mediators
   - Operation: it's the largest scope; the property will live until the end of the service trough the different sequences
   - Registry: used to get properties from the registry
   - System: get Java system properties
   - Transport: the property will be sent as a transport header

   Logging a property is done as follows:
    <log [level="string"] [seperator="string"]>
     <property name="string" (value="literal" | expression="[XPath|json-eval(JSON Path)]")/>
     </log>

     There are six Categories of logging:
     - TRACE
     - DEBUG
     - INFO
     - WARN
     - ERROR
     - FATAL

     there also four levels of logging:

     - Custom: Show the properties configured inside the element
     - Full: shows the Show To, From, WSAction, SOAPAction, ReplyTo, and MEssageID headers and the current payload
     - headers: Log all the SOAP headers
     - Simple: Log To, From, WSAction, SOAPActionm ReplyTo and MessageID headers

     by default the log is placed at <WSO2_HOME>/repository/log/wso2carbon.log

     - there are multiple types of send mediators, when in the out sequence it will call the calling client 
     - when the <send/> mediator is used with not further information it will use the given implicit endpoint
     - inline definition is as shown
     <send>
      <endpoint>
       <address uri="http://localhost:8280/services/"
      </endpoint>
     </send>
     - with a named endpoint is shown below
     <send recieve="OutSequence">
      <endpoint key="CreditEPR"/>
     </send>

     The Respond mediator stops the current message and sends the payload back to the requesting client
     written as 
     <respond/>

     The loopback mediator moves the current message to the out sequence
     written as
     <loopback/>

     The Drop Mediator stops processing the current message, only when configured inside the sequence sends an HTTP 202 accepted response to the client
     written as
     <drop/>

     The Sequence mediator throws the processing of the named sequence or registry sequence
     named sequence goes as the following:
     <sequence key="namedSequence"/>
     the registry sequence syntax is as follows:
     <sequence key="conf:/path/to/registrySequence"/>

     The script Mediator can use different scripting languages such as Javascript, Groovy and Ruby
     inline script syntax starts as the following
     <script language="js | groovy | rb" [function="function name"]>
     <![CDATA[
      //script code
     ]]
     <script/>

     registry script syntax starts as the following:
     <script key="path/to/script" language="(js | groovy | rb) [function="nameOfTheFunction"]">
      [<include key="string">]
     <script/>

     a sequence is triggered when there is no available axis2 services
     
     you can filter the incoming messages as the following

     <filter regex="http://localhost:9000.*" source="get- property('To')">
     <then>
     </then>
     <else>
     <else/>
     </filter>

     the fault and in and out sequence are the generic options, it also is possible to create custom sequences by doing the following

     <sequence name="string" [onError="string"][key="string"][trace="enable"][statistics="enable"]></sequence>

     Onerror attribute sets the sequence that will be triggered when there's a problem during the processing of the seuence, instead of the default sequence

     statistics to anble statistics collection which tracks number of messages proccesed and their processing times

     trace enable trace collection in which the message will write ttracing information trough each mediation step

     the transformer proxy recieves the request and then applies a transformation using the XSLT language before sending it to the backend service, it can also
     change the backend response before sending it back to the client

     a secure proxy applies the WS-Security Standard security on a non scure backend to mae it more secure

     WSDL Based proxy is used when you already have the wsdl

     Logging Proxy is similar to a pass trough proxy but it also has the ability to log all incoming and outgoing requests

     simple proxy only gets the message and forwards it to the backend

     custom proxies are for when there is need for a more complex type of proxie which doesn't fall in the previous Categories
     you have to configure the in out and fault sequence the endpoints, transport etc.

     API's are used as REST instead os SOAP, API's are simpler to develop and have better performance and scalability

     <api name="API_NAME" context="URI_PATH_OF_API" [hostname="HOST_NAME_OF_SERVER][port="PORT"]>
      <resource [methods="GET|POST|PUT|DELETE|OPTIONS|HEAD|PATCH"] [uri-template="URI_TEMPLATE"|url-mapping="URL_MAPPING"]/>
    
    you either choose the uri-template or url-mapping as your standard

    when choosing a url mapping you have three types of patterns you can choose e.g:
    - Path Mapping: all the paths which start with: /resource/*
    - Extension mappings: only the requests starting with the extensions will be listened to:  *.jag
    - Exact mappings: only the requests with the exact mapping will be listened too: /resource

    to read the incoming parameters you can use the following:
    - POST: json-eval($.nameParameter)
    - GET: $ctx:query.param.nameParameter

    example is:
    <api context=/urlmappingapi>
    <resource methods="GET" url-mapping="/getParam">
    <InSequence>
    <property name="Value of GET param" expression="$ctx:query.param.param"/>
    <InSequence/>
    <resource/>

    input = http://localhost:8280/urlmappingapi/getParam?param-getParam

    <api context=/urlmappingapi>
    <resource methods="POST" url-mapping="/postParam"
    <inSequence>
     <property name="Value of POSt param" expression="json-eval($.param)">
    </inSequence>

    input =
    curl -H "Content-Type: application/json" -X POST
    -d {"param":"postParam"}
    http://localhost:8280/urlmappingapi/postParam 

    with URI Templates we can assign the variables trough the url like: /resource/{param1}/{param2}

    to read the variables you should use the get-property('uri.var.nameParameter')

    the next code will take either GET or POST

    <api name="UriTemplateAPI" context="/uritemplateapi">
     <resource methods="POST GET" uri-template = "/resource/{param1}/{param2}">
     <inSequence>
     <property name="Value of param1" expression="get-property('uri.var.param1')/">
     <property name="Value of param2" expression="get-property('uri.var.param2')"/>
     </inSequence>     
     </resource>
    </api>

    this can be done trough either a: 
    GET : curl http://localhost:8280/uritemplateapi/resource/P1/param2

    or

    POST : curl -X POST http://localhost:8280/uritemplateapi/resource/P1/param2

    you have besides the API and Proxies another service which is called the inbound endpoint,
    this skips the axis2 layer and gets directly from the transport layer to the mediation layer,
    this leads to not having to reboot the server on every change there are four types of inbound endpoints e.g:
    - Listening
    - Polling
    - Event-Based
    - Custom

    LISTENING
    ===========================

    Inbound Endpoints have different types of protocols such as HTTP,HTTPS,HL7,CXD Websocket and Secure Websocket

    the basic configuration of the inbound endpoint you need the following:
    - Endpoint Name
    - Type
    - Sequence: the sequence which will be processed on an incoming request
    - inbound.http.port: port that will open dynamically for the listen request

    for testing we need to make a request to that port as given: curl http://localhost:8765

    POLLING
    ==============================
    this type of inbound endpoints continously polls for data at a given interval time, when data is available will this data trigger a specific sequence
    with the data as a payload

    there are three different polling types:

    - File: for FTP,SFTP and FILE connections
    - JMS: Java Message Service protocols
    - Kafka: for Apache Kafka protocols

    to test it you can add a file that directs to the url in the given parameter called pollinginboundendpoint.txt in C:\Temp

    EVENT 
    ==============================
    event based inbound endpoint will establish the connection with the configure server when it's created and then stay waiting for a specific configured event

    out of the box you have Message Queue Telemetry Transport called MQTT and RabbitMQ protocols

    the given image settings will trigger the main sequence when recieving an event on the set localhost port

    image 2.png

    CUSTOM
    =============================
    when the previously given inbound endpoints are not enough you can create your own custom , here you need to create a java class with all the logic and 
    the specific inbound type.

    =============================

    With Tasks we can setup up the execution of a service to be processed on a specific date and time, for a specified number of times

    You can find it under Main | Manage | Services | Add | Data Service | Scheduled Task

    you will have some general options to fill in with two options for scheduling type: Data Service Operation for invoking an existing data service Operation
    and Data Service Task Class for invoking a custom task class  


    there are also sheduled Tasks at Main | Manage | Service Bus | Scheduled Tasks

    this one allows us to create tasks for launch proxy, sequences, endpoints, and so once

    we can schedule tasks in three different ways

    1. specifying the number of times and the interval to launch the process
    2. setting up a cron expression
    3. design a task that will only be executed once the server starts

    there are multiple parameters which you can fill in like:
    - Task implementation: java class implementation default is org.apache.synapse.startup.tasks.MessageInjector
    - Registry Key: PAth in the registry to execute the task
    - Inject To: specify if its a proxy or sequence
    - Trigger Type:
     - Simple: specify count and interval
     - Cron: specify the cron expression
    - Pinned Servers: List of servers to launch the task


    DataService can be built using the WSO2 EI management console not advisable for production environment,
    you have two choices the Generate Wizard which automaticly creates a data serivce with the CRUD operation required to manage one or several tables
    or the creatre wizard in which you customize every step's configuration

    or you can use the WSO2 EI Tooling, this is the advised way to do it, here you are allowed to generate carbon files for the deliveries,  as well as manage your
    code in the github repository

    The management console enables you to quickly perform modification as well as test them which is  a pro of using it 
    
    WSO2 EI allows you to create the following data sources such as Relational Database Management System (RBDMS most used one) CSV, EXCEL, ODS, Cassandra, Google Spreadsheets, RDF,
    and any web page.

    go to Configure | DataSources and click on Add DataSource after that

    here you get multiple parameters to choose from one of which is the URL which is the adress to connect to the database
     one example is jdbc:mysql://localhost:3306/wso2ei

    You can define custom data sources using XML and place them in $EI_HOME/conf/datasources

    The Create wizard can be found in the Management Console under Main | Data Service | Create

    when you created a new datasource you get the option to add a new query, do this
    inside the SQL box type in the Data Manipulation Language (DML)
    type in the following SQL statement to get all the records
    SELECT ID, Name, CountryCode, District, Population FROM city

    the xml output and input could be autogenerated

    when using JSON you should change the WSO2_EI/conf/axis/axis2.xml and WSO2_EI/conf/axis/axis_client.xml must containerthe next
    <parameter name="httpContentNegotiation">true</parameter>

    JSON has no ability to autogenerate the output and input this has to be done manually

    this will result in the next

    {
      "Cities":{
        "City":[
          {
            "CityID": "$1",
            "CityName": "$2",
            "CountryCode": "$3",
            "District": "$4",
            "Population": "$5"
          }
        ]
      }
    }

    when using input parameters the input autogeneration tool won't work this should be dobe manually, the output works fine, when using
    input variable use the variable name with the : symbol before it like this
    SELECT ID, Name, CountryCode, District, Population FROM city WHERE CountryCode = :countryCode AND population < :population

    when adding an input query trough the input mapping option you will have multiple options too fill in, one of which is the ordinal which should be set to to 1 for the first and 2 for the secondetc.

    when adding a new query in which you want to Insert a new row you can do it by choosing the general options and for the query you should use
    INSERT INTO city (Name, CountryCode, District, Population) VALUES (?,?,?,?)

    here the ordinal is set by setting every query which is subdivided into it's position, as the first query should be 1 the second should be 2

    when choosing Return Generated Keys you get the ability to show the auto-incremented id column

    when updating you should use the following SQL query UPDATE city SET Name=?,CountryCode=?, District=?,Population=? WHERE id=?
    here the option Return Updated Row Count should be chosen which will show you the autogenerated output mapping

    Deleting trough SQL is done the same way, but ith the following SL Query DELETE FROM city WHERE ID=?

    the next page when the SQL is Done should shows the operations in here you can autogenerate all the xml to SOAP operations for JSON the REST service will be built later

    when clicked next the Resource list will be shown here you will create the REST resources
    you will get multiple options from which you can choose, one of the options is the Enable Streaming option, this will wire the results directly instead of storing the complete result in memory

    this can't be tested inside the WSO2 EI built in tester but should be done trough SOAPUI as the header Content-Type = application/json can't be set

    there is another way to generate SOAP data services for CRUD Operations, this is hid under Services | Data Service | Generate

    it is best practice to use the create the skeleton using the WSO2 Tooling and develop it using the Management Console wizard , you can easily updatethe data service skeleton in eclipse by clicking on Edit Data 
    for the data service, where you will get the XML code of the data service

    when importing the data service into eclipse both services should have the same name

    when importing a data service you should get rid of all descriptions to the operations and resources in our data service as this will lead to an error when importing

    To change a url with the variables given as url parameters you can change the URL from /flights/get URL PARAMETERS from-London to=Liverpool date=15/12/2017 to an xml output
    this is done trough the following payload where args is the dynamic option variable 

    <api xmlns="http://ws.apache.org/ns/synapse" name="flights" context="/flights">
     <resource methods="POST" uri-template="/get?from={from}&to={to}&date={date}">
      <inSequence>
       <payloadFactory media-type="xml">
        <format>
         <flight>
          <from>$1</from>
          <to>$2</to>
          <date>$3</date>
         </flight>
        </format>
        <args>
         <arg evaluator="xml" expression="get property('uri.var.from')"></arg>
         <arg evaluator="xml" expression="get property('uri.var.to')"></arg>
         <arg evaluator="xml" expression="get property('uri.var.date')"></arg>
        </args>
      </payloadFactory>


      the same can be done trough the script mediator this is done trough the following
       <api xmln="http://ws.apache.org/ns/synapse" name="flights context="/flights">
        <resource methods="POST" uri-template="/get?from={from}&to={to}&date={date}">
         <inSequence>
          <script language="js">
          <![CDATA[
            var from = mc.getProperty("uri.var.from");
            var to = mc.getProperty("uri.var.to");
            var date = mc.getProperty("uri.var.date");
            mc.setPayloadXML(
              <flight>
               <from>{from}</from>
               <to>{to}</to>
               <date>{date}</date>
              </flight>
            );
          ]]>
         </inSequence>


 to change the format of a message you can do this trough the following element

<property name="messageType" value="string" scope="axis2"></property>

an example is the transformation to JSON

<propert name="messageType" value="application/json" scope="axis2"></property>

the XQuery mediator allows us to make XQuery transformations over the payload
the syntax is as follows:

<xquery key="string" [target="xpath"]>
 <variable name="string" type="string" [key="string"]
 [expression="xpath"] [value="string"]/>?
</xquery>

in the next command we change from JSON to XML format before sending it to the client

in the out sequence we need to place the XQuery mediator:

<xquery key="gov:/xquery/flights.xq">
 <varable name="payload" type="ELEMENT"/>
</xquery>

the flights.xq willl be saved in the registry with the following transformation
<x>
 <![CDATA[
  declare variable $payload as document-node() external;
   <flights>
    <flight>
     <company> {$payload//company/child::text()}</company>
     <time>{$payload//time/child::text()}</time>
     <price>{$payload//price/child::text()}</price>
    </flight>
   </flights>
 ]]
</x>

modifying instead of changing content format is changing the content, this is done trough one of the following:
Enrich mediator, Script mediator, XSLT mediator, FASTXSLT mediator, XQuery mediator, Smooks mediator.
The Enrich mediator allows you to add siblings and children to a message.

the syntax is:
<enrich>
 <source [clone=true|false] [type=custom|envelope}body|property|inline] xpath="" property=""/>
 <target [action=replace|child|sibling]
 [type=custom|envelope|body|property|inline]
 xpath="" property=""
</enrich>

clone = when the message will be cloned or used as a reference false by default
Source = has the information to add to the to the payload
Target = where the information of the source tag must be placed


one example is we change the xml values from

<flight>
 <from>London</from>
 <to>Liverpool</to>
 <date>15/7/2017</date
</flight>

<flight>
 <currentDate>2017.12.15</currentDate>
 <from>London</from>
 <to>Liverpool</to>
 <date>15/7/2017</date>
</flight>

this is done in two steps, the first part is by adding the currentDate element after which you add the value inside this element

this is done trough the following code

<api xmlns="http://ws.apache.org/ns/synapse" name="flight" context="/flights">
 <resource methods="POST" uri-template="/get?from={from}&to={to}&date={date}">
  <inSequence>
   <enrich>
   <source clone="false" type="inline">
   <currentDate xmlns=""></currentDate>
   </source>
    <target action="child" type="custom" xpath="//flight">
    </target>
   </enrich>
   <property name="date" scope="default" expression="get-property('SYSTEM_DATE','yyyy.MM.dd')"/>;
   <enrich>
    <source clone="false" type="property" propery="date"/>
    <target action="child" type="custom" xpath="//currentDate">
    </target>
    </enrich>
  </inSequence>

  Message transformation is different than enriching as in this you have a totally different structure which is less efficient than to do it trough the enrich mediator

this must be done trough the XSLT, FASTXSLT, XQuery, Smooks, or Script mediator

The XSLT Mediator is used for transforming XML messages
the syntax is the following
<xslt key="string" [source="xpath"]>
 <property name="string" (value="literal" | expression="xpath")/>*
 <feature name="string" value="true | false" />*
 <resource location="string" key="string/>*  
</xslt>

this can be done trough the following element inside the resource
<xslt key="gov:/xslt/flights.xslt">
</xslt>

inside the registry the following will be saved

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
<xsl:output method="xml" indent="yes" encoding="utf-8"/>
<xsl:template match=""/">
<flights>
 <origin>
  <xsl:value-of select="//from/text()"
 </origin
</flights>

FastXSLT works like XSLT but instead of a payload it transforms the message stream instead of the payloadit can be called trough the following
<fastXSLT key="string"/>


in the next chapter we will discuss the mediators that allow us to apply logic and use routing to make the changes we need to happen

these are the following:
 - Validate mediator
 - Filter mediator
 - Switch ediator
 - Conditional router mediator
 - Rule mediator

the following validates the XML message if it consists of the right input structure and order of elements
this is done trough the validate mediator
which evaluates the content inside the soapBody by default it is possible to use XPath expressions for evaluating a concrete part of the payload

<validate [source="xpath"]>
 [<property name="validation-feature-id" value="true|false"/>*]
 [<resource location="string" key="string"/>+]
 <schema key="string"/>+
  <on-fail>
  mediator+
  </on-fail>
</validate>

in here the source is the xpath expression for the message to evaluate
the property specifies whether those features are active or inactive
resource include if other files are needed for the schema file
schema references the XSD file for validating the message
the on-fail tag has the mediator to execute inc ase the message is not correct

the next example we will validate all the contetn of the payload over the XMLSchema.xsd&XSD 
files and if the current message is not correct, create a log with the description of the error,
 format a SOAP fault message, and send it back to the client that makes the request to the service:

 <validate>
  <schema key=" conf:/XMLSchema.xsd"/>
  <on-fail>
  <log level="custom">
   <property name="ERROR" value="Invalid Request"/>
  </log>


  <makefault>
   <code value="tns:Reciever"
   xmlns:tns="http://www.w3.org/2003/05/soap-envelope"/>
   <reason value="Invalid Request"/>
  </makefault>
  <respond/>
  </on-fail>
 </validate>


the same can be done for a specific path over a JSON schema or a complete JSON payload

below is the syntax

<validate [source="JSONPath"]>
 [<resource location="string" key="string"/>+]
 <schema key="string">+
 <on-fail>
  mediator+
  </on-fail>
  </validate>

- here Source is the JSONPath expression for the message to evaluate. when it is not configured, all of the payload will be evaluated
- the resources include other files needed for the schema file
- schema references the JSON file for validating the message
- the on-fail tag as the mediator to execute in case the message is not correct

Following the previous content the implementation would be the next

<validate source="json-eval($.rootElement)">
<schema key="conf:/JSONSchema.json"/>
<on-fail>
<log level="custom"
 <property name="ERROR" value="Invalid Request"/>
</log>
<payloadFactory media-type="json">
<format>{"Error":"Invalid Request"}</format>
</payloadFactory>
<property name="HTTP_SC" value="500" scope="axis2"/>
<respond/>
</on-fail>
</validate>

Boolean fitering is done trough the filter mediator
the syntax for it is the following

<filter (source="[XPath|json-eval(JSONPath)]" regex="string") | xpath="[XPath | boolean]">
 <then [sequence="string"]>
  mediator+
  </then>
  <else [sequence="string"]>
  mediator+
  </else>
</filter>

one example is shown below here where the parameter value gets tested if it's a POST or not

<filter xpath="boolean($axis2:HTTP_METHOD = 'POST')">
 <then>
  <log>
   <property name="Method" value="POST"></property>
  </log>
  <property name="flightID" expression="json-eval($.flightID)"/>
 </then>
 <else>
  <log>
   <property name="Method" value="GET"></property>
  </log>
  <property name="flightID" expression="$ctx:query.param.flightID"/>
 </else>

it is also possible to execute a sequence written in the registry and without the else element as is shown below

<filter source="boolean(get-property('flightID'))" regex="false">
<then sequence="conf:/invalidParams"></filter>

it is also possible to check for multiple parameters in the same filter mediator
<filter source=""boolean(get-property('flightID'))" and boolean(get-property('date'))>

when more than one cases need to be checked you will need to use a switch mediator
the syntax should be done trough the following

<switch source="[XPath|json-eval(JSON Path)]"
 <case regex="string">
  mediator+
 </case>
 <default>
 mediator+
 </default>
</switch>

using the switch mediator has performance improvements on the boolean when used for multiple clauses

one example of a switch mediator is the following

<switch source="//Country/name">
 <case regex="Spain">
  <property name="code" value="ES"/>
 </case>
 <case regex="UK">
  <property name="code" value="GB"/>
 </case>
 <case regex="Germany">
  <property name="code" value="DE"/>
 </case
 <default>
  <property name="code" value="UKNOWN">
 </default>

 the conditional router mediator we can define different rules and throw a specific sequence to process this request

 the syntax is as following

 <conditionalRouter continueAfter="(true|false)">
 <conditionalRoute breakRoute="(true|false)">
  <condition/>
  <target/>
 </conditionalRoute>+
 <conditionalRouter/>

 continueAfter specifies if the routing must continue when a child route is executed
 breakRoute configures whether a matching route will break the router
 Target contains the name of the sequence to execute

 an example is shown below how it works

 <conditionalRouter conitinueAfter="false">
 <conditionalRoute>
  <condition>
   <match xmlns="" type="url" regex="/flights/get.*"/>
  </condition>
  <target sequence="flights_IN_SEQ">
 </conditionalRoute>
 </conditionalRouter>

it is also possible to have multiple parameters as shown below, where the headers get checked

<conditionalRouter continueAfter="false">
<conditionalRoute breakRoute="false">
 <condition>
  <and xmlns="">
   <match type="url" regex="/flights/get.*"/>
   <match type="header" source="company" regex="PacktAir"/>
  </and>
 </condition>
 <target
</conditionalRoute>
</conditionalRouter>

it is also possible to add an or clause which will execute even if the previouse and clause is not triggered

<conditionalRouter continueAfter="false">
 <conditionalRoute breakRoute="false">
  <condition>
   <and xmlns="">
    <match type="url" regex="/flights/get.*"/>
    <match type="header" source="company" regex="PacktAir"/>
   </and>
   <or>
    <equal type="param" source="company" value="PacktAir"/>
   </or>
  </condition>
  <target sequence="PacktAir_IN_SEQ"/>
 <conditionalRoute>
</conditionalRouter>

below is shown a conditional router which has no sepcific header

<conditionalRouter continueAfter="false">
 <conditionalRoute breakRoute="false">
  <condition>
   <and xmlns="">
    <match type="url" regex="/flights/get.*"/>
    <match type="header" source="company" regex="PacktAir"/>
   </and>
   <or>
    <equal type="param" source="company" value="PacktAir"/>
   </or>
   <not>
    <equal type="param" source="next24Hr" value="false"/>
   </not>
  </condition>
  <target sequence="PacktAir_IN_SEQ"/>
 </conditionalRoute>
</conditionalRouter>

the rule mediator is similar to the conditional router only it has more options to manipulate the data with,

the syntax goes as follows

<rule>
 <ruleset>
  <source [key="xs:string"]>
   [in-Lined]
  </source>
  <creation>
   <property name="xs:string" value="xs:string"/>*
  </creation>
 </ruleset>

<session type="[stateless|stateful]">*

<facts>
 <fact name="xs:string" type="xs:string"
 expression="xs:string" value="xs:string"/>+
</facts>

<results>
 <result name="xs:string" type="xs:string" expression="xs:string" value="xs:string"/>*
</results>

[
  <childMediators>
   <mediator/>*
   </childMediators>
]
</ruleset>
</rule>

- Ruleset contains the list of rules to apply
- the session configures the type of session 
- the facts are sent by tje rule service client
- the results is the information after applying the rules
- the ChildMediators contains the logical to apply

in the next example we will use the rule mediator to read the name of the country of the incoming request and then obtain the code with that country

<rule xmlns="http://wso2.org/carbon/rules">
 <source>soapBody</source>
 <target action="replace" resultXpath="//country::text()">$country</target>
 <ruleSet>
  <properties/>
  <rule resourceType="regular" sourceType="inline">
  <![CDATA[
    rule "Country ES" no-loop true
    when
     country:String()eval(country.equals("Spain"))
     then
       update(drools.getWorkingMemory().getFactHandle(country),"ES");
       end

       rule "Country GB" no-loop true
       when
         country: String()eval(country.equals("UK"))
       then 
         update(drools.getWorkingMemory().getFactHandle(country),"GB");
       end

       rule "Country DE" no-loop true

       when
       country: String()eval(country.equals("Germany"))
       then
       update(drools.getWorkingMemory().getFactHandle(country),"DE");
       end


  ]]
 </ruleSet>
 <input wrapperElementName="flights">
  <fact elementName="country" type="java.lang.String" xpath="//country::text()"/>
 </input>
 <output wrapperElementName="flights">
  <fact elementName="country" type="java.lang.String".>
 </output>
</rule>

Security consist of the following:
- Authentication = the act of veryfing that one user is really that user and is not trying to spoof another user
- availability = the service must be available at for the user when needed
- Confidentiality = the services are only available to the users who have the permissions to consume them
- Integrity = the data cannot b modified in an unauthorized or undetected manner
- Nonrepudiation = The Service consumer cannot deny having recieved a response or a request.

throttling is the ability applying different policies to avoid heavy performance loads and restricting access to an IP adress

Security
===========================================

- UsernameToken
simplest and most used scenario in which the user sends the UsernameToken in the message and it's validated against the user stores in EI

- Non-repudation
this is done trough an X509 certificate in which the sender signs it with the private key, after which the reciever can check
the client with it's public key

- Integrity
the client generates a symmetric key and sign the message with that key. Then, it encrypts the symmetric key with the service'same
public key and sends it inside the SOAP Message, only the service/recipient can open the the mesage with a private key

- Confidentiality
the clients generates a symmetric key and encrypts the message with that key, Then it encrypts the symmetric key with the service's public key
and send it inside the SOAP message, the service decrypts the symmetric key using their private key, and with this symmetric key, decrypts the message

- Sign and encrypt - X509 authentication 
 the client encrypts the message using the service public key and sign it using their private key, the service decrypts the message using their private key
 and checks the signature over the client public key

- Sign and Encrypt - Anonymous client
 The client generates a symmetric key and encrypts and signs the mesage with that key. then it encrypts the symmetric key with the service's public key and sends it inside the SOAP message. The Service decrypts the
 symmetric key using their private key and with this symmetric key decrypts the message and checks the signature

- Encrypt only - UsernameToken authentication
this scenario has a mix between the UsernameToken and Confidentiality
the client generates a symmetric key and encrypts the message with that key.
Then, it encrypts the symmetric key with the service's public keyand sends it inside the SOAP message. the service decrypt the symmetric key using their private
key and with this symmetric key decrypts the message. the user sends the UsernameToken in the message
and it's validated against the user stores setting up in the EI Server


- Sign and Encrypt UsernameToken Authentication
this scenario is a mix between the UsernameToken and Sign and Encrrypt - Anonymous clients
the client generates a symmetric key and encrypts and sign the message with that key. then it encrypts the symmetric key with the service's public key
and sends it inside the SOAP message. The service decrypts the symmetric key using their private key, and with this symmetric key, decrypts the message and checks the signature.
The user sends the UsernameToken in the message and its validated against the user stores setting up in the EI server.

Secure conversation - Sign only Service as STS - Bootstrap policy - Sign and encrypt, x509 authentication
this scenario establishes a security context between the client and the service using the x509 certificates All the communication in the security context
is signed using the keys from the security context

Secure converstaion - Sign only - Service as STS - Bootstrap policy - Sign and encrypt, anonymous clients
this scenario is equal to the previous with the only difference being that the messages inside the security context are encrypted instead of signed,
this makes the environment safer because the message is not visible to third parties

Secure conversation - Sign and Encrypt - Service as STS - Bootstrap policy - Sign and encrypt, X509 authentication
this is the scenario in which the previous two are combined into a signed and encrypted message

Secure conversation - Sign only - Service as STS - Bootstrap policy - Sign and encrypt, anonymous clients
In this scenario we also have a security context between the client and the service, but the client doesn't have a X.509 certificate, 
so the context is established using a symmetric key

Secure conversation - Sign and Encrypt - Service as STS - Bootstrap policy - Sign and encrypt, anonymous clients
Same as before but encrypted instead of signed

Secure conversation - Encrypt only - Service as STS - Bootstrap policy - Sign and encrypt, UsernameToken authentication
same as before but with the UsernameToken


Secure conversation - Sign and encrypt - Srevice as STS - Bootstrap policy - Sign and encrypt, UsernameToken authentication
same as before but signed and encrypted together

Kerberos token-base security
for this scenario we need a Key Distribution Center KDC and an authentication server to connect to our services, 
in the <EI_HOME>/repository/conf/security path we found two configuration files named krb5.conf with the KDC server configuration an jass,conf with the authorization configuration

For secure communication we can use the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) that will encrypt the message
these protocols use the Public Key Infrastructure (PKI) scenario, in whihc the certificates are used to encrypt and sign the communication

by default the WSO2 Servers are configured with a certificate for localhost that is only suitable for test environments

in order to create a valid certificate for the server we will use the keytool program which is the default program inside the JDK (Java Development Kit)

By default the Enterprise Integrator does not provide any athentication method for the REST APIs so we need to create a Java program with the
logic of the authentication generate a .jar project, deploy to the server in the <WSO2_HOME>/lib folder and configure the APIs to use this project like handler

in basic authentication scenario the consumer will send the username and password in the authorization header of the request.
This header has the username:password structure codified in the base64 format. in the Java class we get the credentials as follows

String authHeader = (String) headersMap.get("Authorization");
String credentials = authHeader.substring(6).trim();
String decodedCredentials = new String(new Base64().decode(credentials.getBytes()));
String userName = decodedCredentials.split(":")[0];
String password = decodedCredentials.split(":")[1];

<api xmlns="http://ws.apache/org/ns/synapse" name="flights" context="/flights">
 <resource methods="POST" uri-template="/get?from={from}>
  <inSequence>
  </inSequence>
 </resource>
 <handlers>
  <handlers>
   <handler class="org.wso2.rest.BasicAuthHandler"/>
  </handler>
</api>

the next is used to authenticate against wso2 identity Server trough the oauth mediator done by the following

<oauthService remoteServiceUrl="" username="" password="">

in which the remoteserviceurl - the url is of the identity Server

for creating a secured SOAP Proxy we need three different projects 
- the ESB Config Project which will store the proxy
- the Registry Resources Project which will get the security policy
- the Composite Application Project this will create the .car file deployable 

in the proxy we need to configure two properties
- Securty enabled
- Set the path to the previous policy

when to invoke a secure backend using a basic authentication we need to send a header called authorization in the request containing the username and password
joined with : and encoded in base64

<property name="username" value="USERNAME_OF_BACKEND"scope="default" type="STRING" xmlns="http://ws.apache.org/ns/synapse"/>
<property name="username" value="PASSWORD_OF_BACKEND" scope="default" type="STRING" xmlns="http://ws.apache.org/ns/synapse"/>
<property <property expression="fn:concat('Basic ', base64Encode(fn:concat($ctx:username,':',$ctx:password)))"

