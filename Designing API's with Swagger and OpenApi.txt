page: 217

1
==============

image 2 - 1

once an API has been written down we call it described

example of a YAML file which shows images of a dog breed

image 2 - 2.png

here the API is hosted at https://dog.ceo/api
- there is a GET operation with the path / breed/{breedName}/images
- this path has a part called breedName and it is a required string
- a succesfull response will give us a JSON array where each item is an object containing message and status fields
- The message field is an array of string that contain the URL's of dog images

once we have an API definition we can use leverage this, the deinfinitions can be created by tools or by extracting annotation from code,
they they can be transformed into API documentation, server stubs/mocks and client SDK's

other workflows could include:
  - Automating parts of API testing
  - geting early feedback on the design of an API
  - ensuring API consistency
  - Comparing API changes across versions

OpenAPI means the ecosystem whereas Swagger are the tools used

There was an old standatf called WADL

SDK templates can be generated trough Swagger CodeGen or OpenAPI Generator which are usually suficient for all langauges,
but more power can be extracted trough customizing and creating tempates specific to your needs

boilerplate code and stubs can be autogenerated trough OpenAPI definitions,
there is also the possiblity such as using OpenAPI definitions during runtime to act as a router (Having API Operation map to classes and methods in code)
or as a validation layer(where incoming requests will fail validation unless they conform to the OpenAPI definition's schema) these are used more
commonly in microservice-oriented architectures

API design is done trough Agile or other fast acting methods, but longetivity should be standard, Design is more important when making multiple API'safer
as consistency plays an important rule when making multiple API's

OpenApi makes the minimal upfront cost of describing it worth it, trough the automation that is available


2
==================================

low level tools exist for REST API = telnet for HTTP and OpenSSL for HTTPS

Method  URI      Query            params Body
GET     /reviews maxRating (1-5)  N/A


the URI will be placed after the whole URL
e.g:

https:/ /farmstall.designapis.com/v1/reviews

if we add the query parameter we get

https:/ /farmstall.designapis.com/v1/reviews?maxRating=5

GET methods can have body's like POST's but with a size limit, and binary data can't be send

body also allows encryption, a query has the chance that the data would be logged by servers and proxies between your client and server

%20 is URL encoding for spaces

there are two utilities you can use to opena TCP connection (a pipe you can read data from and write into it)
telnet is available on most systems, OpenSSL is on Unix systems only, the following commands are only used on the Unix systems

$ telnet farmstall.designapis.com 80
# Or for HTTPS sites...
$ openssl s_client -quiet -connect farmstall.designapis.com:443

after which the headers are filled in as follows in the headers

Image 2 - 3.png

The above is a GET request, 
POSTS are done as show in the image below

Image 2 - 4.png


3
===============================

When we turn a API into computer readable data we call it a definition e.g YAML,JSON

Image 2 - 5.png

OpenAPI can use both JSON and YAML, but YAML is easier to handwrite

YAML is a superset of JSON because of the use of flow types [],{}
this makes all JSON documents viable YAML types

Image 2 - 6.png

YAML has more advanced features in comparison with JSON, like advanced/custom data types, anchors, etc.

the following image shows not everything has to be filled in, it shows a Request which we know is a GET method with /reviews as context,
and it returns a list of reviews

Image 2 - 7.png

to describe a query parameter which takes the numbers 1-5 we write the following

Image 2 - 8.png

 https://editor.swagger.io/ is a tool we can write our OpenAPI definitions in


 the minimal workable OpenAPI definition has the following :
  - The OpenAPI Identifier and the version
  - the info object with the title and version fields
  - an empty paths object

Image 2 - 9.png

adding a GET to the path as shown below in the image

Image 2 - 10.png

you can add a server field by using
- url: https://farmstall.designapis.com/v1

Image 2 - 11.png


JSON schema is a specification for descrbining JSON Data

OpenAPI 3.0.x supports JSON Schema draft 04 while OpenAPI 3.1+ supports JSON Schema 2020

this schema can be applied to the response to add a response structure to follow, show below

Image 2 - 12.png

{
 "rating": 3
}

can be written in the JSON Schema fragment

type: object
properties:
 rating:
 type: integer
 minimum: 1
 maximum: 5

an object can have the proprties keyword attached to define a property

extra fields are fine by default it can be changed
e.g 

JSON                        Valid     Description
{ "rating": "hi" }          Invalid   Expected a number but found a string.
{ "rating": 100 }           Valid     100 is a valid number.
{ "rating": 100, "a": "b" } Valid     Extra fields are fine (by default)

limits can be set like a minimum and maximum number aswell as numbers with decimals written as decimals or whole numbers as integer

Range   Category      Notes
1xx     Informational The most common is when a websocket connection is upgraded.
2xx     Success       This indicates some form of success, like the general 200 or the 201 for “created.”
3xx     Redirects     The resource has a different location/URI.
4xx     Client error  The client did something wrong, like misspell a resource or provide invalid details.
5xx     Server error  The server hit an error that isn’t a fault of the client.

MIME/media types are the following

Media type       Description
text/html        The HTML you get back from a web server
text/csv         Comma-separated values
image/png        PNG encoded image
application/json JSON data
application/xml  XML data

You may find suffixes in some media types that indicate a wrapper format. For example,
the SVG media type used for scalable images has the media type of image/svg+xml,
which has the suffix +xml. This indicates that the format is XML but that it will be compliant with the SVG schema.
Occasionally API designers will use custom (or vendor) media types to version the
API. These vendor extensions can also make use of a suffix to indicate the wrapper
format. An example of this in the wild is application/vnd.github.v3+json, which
is for version 3 of GitHub’s public API. You’ll note that it uses JSON as a wrapper
format. Y

uuid follows the regex pattern '^[0-9a-fA-F\-]{36}$' 

openAPI uses the regex syntax of Javascript also called ECMAScript

Image 2 - 13.png

multiple types like this
type: [ number, string, null ] 
are only allowed in JSON Schema not in OpenAPI

to make a type nullable set the following 
type: string 
nullable: true

an array can be set trough the items property

type: array
 items:
  type: object
  properties:
   rating:
   type: integer
   minimum: 1
   maximum: 5


request and response added

Image 2 - 14.png
Image 2 - 15.png

there can be only one RequestBody per operation, but each media type can describeits own 
shape and each shape can be made to fit many different bodies

only some operations are allowed to have request bodies, notable ones which restrict
this are GET and DELETE,

Image 2 - 16.png

traling comma's are only alowed when the item is a field or array item, that
isn't the last item

examples can be given

Image 2 - 17.png

path parameters are the variables used in url's
like GET/Reviews/{reviewId}

path parameters have the following required properties
 - name
 - in = location i.e, query, path, header and cookie
 - schema

parameters can also include the following properties
 - required = required or not this parameter is always required for path parameters
 - example
 - deprecated
 - style = how the value will be serialized
 - explode = whether or not to create a seperate instance for each value in arrays and objects
 - allowreserved = whether or not to allow reserved characters i.e / and ?
   usefull for catchall parameters

Image 2 - 18.png


image showing security implementation
Image 2 - 19.png

password and username implementation

Image 2 - 20.png

Authorization is done as the following

Image 2 - 21.png

OpenAPI supports four categories of security
 - apiKey
  - in: header
  - in: query
  - in: cookie
 - http
  - scheme:
 - oauth2
  - flows: {}
 - openIdConnect
  - openIdConnectUrl: <url>

openapi: 3.0.0
# ...
paths:
 # ...
 /reviews:
 post:
 # ...
  security: 
   - MyUserToken: [] 

on top of the arrangement we will use the security parameter
this has an empty array which normally would have a list of scopes that apply
within the security scheme, this is not used with apiKey types only with oauth2

to add the optional security option do the following
openapi: 3.0.3
# ...
paths:
 # ...
  /reviews:
  post:
   # ...
   security: 
    - {} 
    - MyUserToken: []

in here the empty brackets mean that security is optional 

- http—The http type is for the HTTP Basic authentication scheme, which
describes how to send a username and password through the Authorization
HTTP header. It is specified in RFC 7617 (https://datatracker.ietf.org/doc/
html/rfc7617). Just like apiKey, http doesn’t use scopes.

- oauth2—The oauth2 type is for the OAuth 2.0 protocol, which describes a process for delegated authentication. If you’ve ever been to a website and they
asked you to log in with a third-party account (like Google or Facebook), you’ve
experienced what’s often called the “OAuth dance.” And if the third-party
account asked you which information you wanted to share (such as your name
and email), those are the scopes that the API providers allow the API consumer
to access. You can think of scopes as capabilities that are granted to a user of an
API. After “dancing” between two websites, the API provider hands out a bearer
access token that the API consumer can send through the Authorization
HTTP header. OAuth is specified in RFC 6749 (https://datatracker.ietf.org/
doc/html/rfc6749), and there’s also a great website at https://oauth.net/ that
can help you get started with the protocol.

- openIdConnect—The openIdConnect type is for the OpenID Connect protocol,
which itself is an extension of OAuth 2.0, that adds things like automated discovery and standardized endpoints to get user details. You can learn more
about OpenAPI Connect on its website: https://openid.net/connect/.



Image 2 - 22.png

you can tag API's by Category

all metadata options there are 

Image 2 - 23.png

CommonMark is the markdown type which is made use of in OpenAPI

an example of markdown is at https://github.com/designapis/openapi/blob/main/ch08/02.yml

how to add tags 

Image 2 - 24.png

html of swaggerUI

Image 2 - 25.png


2
================

Domain modeling is the process of taking a problem domain (or area of interest) and
creating a description that can be implemented in computer software.

To create a domain model, we map concepts from the real world onto an
abstract representation. We refer to this representation as a model, while being fully
aware that this creates some ambiguity—the term “model” can refer to the representation of a single concept (for example, the “Dog” model) or of the whole area of
interest (the domain model)

You can
think of the concept as the thing in the real world and the model as the thing
we’ll have on paper

r. Attributes are data that describes the concept, such as a name, and
actions are things that the concept can do or things a user can do with the concept

Image 2 - 26.png

An API, however, is more akin to the view layer of an application. It is a clearly
defined boundary between parts of a system, and it can potentially act as an abstraction layer and hide underlying complexity. An API designer should always look at the
API from the perspective of the client and not the server.

you’ll have classes in your application layer, and you’ll have tables in your database. And depending on how the
application is built, there will either be a manual translation between them or an
automated system called an object-relational mapper (ORM). The API can be considered a third layer with its own domain model.

without consciously knowing it, you already created a representation of this domain
model in OpenAPI, using JSON Schema for attributes and API paths for actions.

we’ve already talked
about two types of users: pet owners and pet sitters. Our model needs to accommodate that by including a role attribute.

user stories can be written as, As a <role> I can <capability>, so that <receive benefit>.
to gain insights0

for user stoeries that depend on other stories, we can use this template:

Given <prerequisite>, I can <capability>.

components can store element definements, it can have a schema sub element like

openapi: 3.0.3
info:
 title: PetSitter API
 version: "0.1"
paths: {}
components:
 schemas: {}

 it can be accessed by the $ref command i.e:
 $ref: '#/components/schemas/User'

JSON name conventions should be followed which mean lowercase and without spaces

schema names typically start with an uppercase letter

a user made inside a schema goes as the following

Image 2 - 27.png


when there is a dependency, this is done by the following

Image 2 - 28.png


it is also possible to do this trough the id's shown below

Image 2 - 29.png

there are two (three but this will be shown later) endpoints:
- Resource endpoint
- Collection endpoint

Resources are indiviudal instances of a concept in the domain model e.g a job
or a user

use plurals for storage of multiple models like
/users/123

this is also called a resource endpoint

when you ask for a collection done like this
/users

this is called a collection endpoint

it is possible to limit the items we get trough paginiation(will get later on it)
and filters like the rating limit

it's also common to use the collection endpoint URL combined with the HTTP POST
method to create a new element for which the ID is not yet known because it is assigned by the server

Operation   Method       Typical    path
Create      POST         Collection endpoint (/{schema}s)
Read        GET          Both       collection and resource endpoints
Update      PUT or PATCH Resource   endpoint (/{schema}s/{id})
Delete      DELETE       Resource   endpoint (/{schema}s/{id})

For “Read” and “Delete” operations, there is no request body. If necessary, the input
for “Read” operations, such as filter criteria, typically goes in query parameters.
 For “Create” and “Update” operations, you need to send the JSON representation
of the resource (a JSON structure following the schema) as the request body.

For “Read” operations on resource endpoints, the response is a JSON object following
the schema of the resource. A successful API call gets status code 200 OK. If the
requested resource does not exist, the API should return a 404 Not Found.
 For “Read” operations on collection endpoints, the response is a collection object
that contains an array of resource objects, optionally accompanied by additional fields
with metadata. The field that contains the array of items is often called items or the
name of the resource. Let’s look at an example of a response structure

Image 2 - 30.png

 A successful deletion
request returns a 204 No Content status code, because 200 expects a response body.

For “Create” operations, which are POST requests on the collection endpoint, the
response body is typically empty. Instead, the response contains a Location header
that points to the resource endpoint for the newly created resource. A successful creation request returns a 201 Created status code

representation = account

Image 2 - 31.png

All CRUD implementations in YAML

Image 2 - 32.png
 
POST is done as follows

Image 2 - 33.png

For “Create” operations, which are POST requests on the collection endpoint, the
response body is typically empty. Instead, the response contains a Location header
that points to the resource endpoint for the newly created resource.

API Design-First approach is also called the contract-first approach

for the front end there are three options to mock data to win time 
as the backend usually needs to be finished to work with it

- Mock on the view layer fast but messie
- mock in a central data store , Redux RxJS etc. is clean tradeoff is mock data is still n the source file
- set up a mock API Server like Prism cleanest and least code changes needed due to switch, tradeoff is that data has no logic

Prism creates mockdata dependant on the OpenAPI definitions



