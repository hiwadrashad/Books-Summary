page: 136

1
==============

image 2 - 1

once an API has been written down we call it described

example of a YAML file which shows images of a dog breed

image 2 - 2.png

here the API is hosted at https://dog.ceo/api
- there is a GET operation with the path / breed/{breedName}/images
- this path has a part called breedName and it is a required string
- a succesfull response will give us a JSON array where each item is an object containing message and status fields
- The message field is an array of string that contain the URL's of dog images

once we have an API definition we can use leverage this, the deinfinitions can be created by tools or by extracting annotation from code,
they they can be transformed into API documentation, server stubs/mocks and client SDK's

other workflows could include:
  - Automating parts of API testing
  - geting early feedback on the design of an API
  - ensuring API consistency
  - Comparing API changes across versions

OpenAPI means the ecosystem whereas Swagger are the tools used

There was an old standatf called WADL

SDK templates can be generated trough Swagger CodeGen or OpenAPI Generator which are usually suficient for all langauges,
but more power can be extracted trough customizing and creating tempates specific to your needs

boilerplate code and stubs can be autogenerated trough OpenAPI definitions,
there is also the possiblity such as using OpenAPI definitions during runtime to act as a router (Having API Operation map to classes and methods in code)
or as a validation layer(where incoming requests will fail validation unless they conform to the OpenAPI definition's schema) these are used more
commonly in microservice-oriented architectures

API design is done trough Agile or other fast acting methods, but longetivity should be standard, Design is more important when making multiple API'safer
as consistency plays an important rule when making multiple API's

OpenApi makes the minimal upfront cost of describing it worth it, trough the automation that is available


2
==================================

low level tools exist for REST API = telnet for HTTP and OpenSSL for HTTPS

Method  URI      Query            params Body
GET     /reviews maxRating (1-5)  N/A


the URI will be placed after the whole URL
e.g:

https:/ /farmstall.designapis.com/v1/reviews

if we add the query parameter we get

https:/ /farmstall.designapis.com/v1/reviews?maxRating=5

GET methods can have body's like POST's but with a size limit, and binary data can't be send

body also allows encryption, a query has the chance that the data would be logged by servers and proxies between your client and server

%20 is URL encoding for spaces

there are two utilities you can use to opena TCP connection (a pipe you can read data from and write into it)
telnet is available on most systems, OpenSSL is on Unix systems only, the following commands are only used on the Unix systems

$ telnet farmstall.designapis.com 80
# Or for HTTPS sites...
$ openssl s_client -quiet -connect farmstall.designapis.com:443

after which the headers are filled in as follows in the headers

Image 2 - 3.png

The above is a GET request, 
POSTS are done as show in the image below

Image 2 - 4.png


3
===============================

When we turn a API into computer readable data we call it a definition e.g YAML,JSON

Image 2 - 5.png

OpenAPI can use both JSON and YAML, but YAML is easier to handwrite

YAML is a superset of JSON because of the use of flow types [],{}
this makes all JSON documents viable YAML types

Image 2 - 6.png

YAML has more advanced features in comparison with JSON, like advanced/custom data types, anchors, etc.

the following image shows not everything has to be filled in, it shows a Request which we know is a GET method with /reviews as context,
and it returns a list of reviews

Image 2 - 7.png

to describe a query parameter which takes the numbers 1-5 we write the following

Image 2 - 8.png

 https://editor.swagger.io/ is a tool we can write our OpenAPI definitions in


 the minimal workable OpenAPI definition has the following :
  - The OpenAPI Identifier and the version
  - the info object with the title and version fields
  - an empty paths object

Image 2 - 9.png

adding a GET to the path as shown below in the image

Image 2 - 10.png

you can add a server field by using
- url: https://farmstall.designapis.com/v1

Image 2 - 11.png


JSON schema is a specification for descrbining JSON Data

OpenAPI 3.0.x supports JSON Schema draft 04 while OpenAPI 3.1+ supports JSON Schema 2020

this schema can be applied to the response to add a response structure to follow, show below

Image 2 - 12.png

{
 "rating": 3
}

can be written in the JSON Schema fragment

type: object
properties:
 rating:
 type: integer
 minimum: 1
 maximum: 5

an object can have the proprties keyword attached to define a property

extra fields are fine by default it can be changed
e.g 

JSON                        Valid     Description
{ "rating": "hi" }          Invalid   Expected a number but found a string.
{ "rating": 100 }           Valid     100 is a valid number.
{ "rating": 100, "a": "b" } Valid     Extra fields are fine (by default)

limits can be set like a minimum and maximum number aswell as numbers with decimals written as decimals or whole numbers as integer

Range   Category      Notes
1xx     Informational The most common is when a websocket connection is upgraded.
2xx     Success       This indicates some form of success, like the general 200 or the 201 for “created.”
3xx     Redirects     The resource has a different location/URI.
4xx     Client error  The client did something wrong, like misspell a resource or provide invalid details.
5xx     Server error  The server hit an error that isn’t a fault of the client.

MIME/media types are the following

Media type       Description
text/html        The HTML you get back from a web server
text/csv         Comma-separated values
image/png        PNG encoded image
application/json JSON data
application/xml  XML data

You may find suffixes in some media types that indicate a wrapper format. For example,
the SVG media type used for scalable images has the media type of image/svg+xml,
which has the suffix +xml. This indicates that the format is XML but that it will be compliant with the SVG schema.
Occasionally API designers will use custom (or vendor) media types to version the
API. These vendor extensions can also make use of a suffix to indicate the wrapper
format. An example of this in the wild is application/vnd.github.v3+json, which
is for version 3 of GitHub’s public API. You’ll note that it uses JSON as a wrapper
format. Y

uuid follows the regex pattern '^[0-9a-fA-F\-]{36}$' 

openAPI uses the regex syntax of Javascript also called ECMAScript

Image 2 - 13.png

multiple types like this
type: [ number, string, null ] 
are only allowed in JSON Schema not in OpenAPI

to make a type nullable set the following 
type: string 
nullable: true

an array can be set trough the items property

type: array
 items:
  type: object
  properties:
   rating:
   type: integer
   minimum: 1
   maximum: 5


request and response added

Image 2 - 14.png
Image 2 - 15.png

there can be only one RequestBody per operation, but each media type can describeits own 
shape and each shape can be made to fit many different bodies

only some operations are allowed to have request bodies, notable ones which restrict
this are GET and DELETE,

Image 2 - 16.png

traling comma's are only alowed when the item is a field or array item, that
isn't the last item

examples can be given

Image 2 - 17.png

path parameters are the variables used in url's
like GET/Reviews/{reviewId}

path parameters have the following required properties
 - name
 - in = location i.e, query, path, header and cookie
 - schema

parameters can also include the following properties
 - required = required or not this parameter is always required for path parameters
 - example
 - deprecated
 - style = how the value will be serialized
 - explode = whether or not to create a seperate instance for each value in arrays and objects
 - allowreserved = whether or not to allow reserved characters i.e / and ?
   usefull for catchall parameters

Image 2 - 18.png


image showing security implementation
Image 2 - 19.png

password and username implementation

Image 2 - 20.png

Authorization is done as the following

Image 2 - 21.png

OpenAPI supports four categories of security
 - apiKey
  - in: header
  - in: query
  - in: cookie
 - http
  - scheme:
 - oauth2
  - flows: {}
 - openIdConnect
  - openIdConnectUrl: <url>

openapi: 3.0.0
# ...
paths:
 # ...
 /reviews:
 post:
 # ...
  security: 
   - MyUserToken: [] 

on top of the arrangement we will use the security parameter
this has an empty array which normally would have a list of scopes that apply
within the security scheme, this is not used with apiKey types only with oauth2

to add the optional security option do the following
openapi: 3.0.3
# ...
paths:
 # ...
  /reviews:
  post:
   # ...
   security: 
    - {} 
    - MyUserToken: []

in here the empty brackets mean that security is optional 

- http—The http type is for the HTTP Basic authentication scheme, which
describes how to send a username and password through the Authorization
HTTP header. It is specified in RFC 7617 (https://datatracker.ietf.org/doc/
html/rfc7617). Just like apiKey, http doesn’t use scopes.

- oauth2—The oauth2 type is for the OAuth 2.0 protocol, which describes a process for delegated authentication. If you’ve ever been to a website and they
asked you to log in with a third-party account (like Google or Facebook), you’ve
experienced what’s often called the “OAuth dance.” And if the third-party
account asked you which information you wanted to share (such as your name
and email), those are the scopes that the API providers allow the API consumer
to access. You can think of scopes as capabilities that are granted to a user of an
API. After “dancing” between two websites, the API provider hands out a bearer
access token that the API consumer can send through the Authorization
HTTP header. OAuth is specified in RFC 6749 (https://datatracker.ietf.org/
doc/html/rfc6749), and there’s also a great website at https://oauth.net/ that
can help you get started with the protocol.

- openIdConnect—The openIdConnect type is for the OpenID Connect protocol,
which itself is an extension of OAuth 2.0, that adds things like automated discovery and standardized endpoints to get user details. You can learn more
about OpenAPI Connect on its website: https://openid.net/connect/.



Image 2 - 22.png

you can tag API's by Category

all metadata options there are 

Image 2 - 22.png

CommonMark is the markup type which is amde use of in OpenAPI