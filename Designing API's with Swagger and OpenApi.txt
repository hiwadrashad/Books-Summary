page: 354

1
==============

image 2 - 1

once an API has been written down we call it described

example of a YAML file which shows images of a dog breed

image 2 - 2.png

here the API is hosted at https://dog.ceo/api
- there is a GET operation with the path / breed/{breedName}/images
- this path has a part called breedName and it is a required string
- a succesfull response will give us a JSON array where each item is an object containing message and status fields
- The message field is an array of string that contain the URL's of dog images

once we have an API definition we can use leverage this, the deinfinitions can be created by tools or by extracting annotation from code,
they they can be transformed into API documentation, server stubs/mocks and client SDK's

other workflows could include:
  - Automating parts of API testing
  - geting early feedback on the design of an API
  - ensuring API consistency
  - Comparing API changes across versions

OpenAPI means the ecosystem whereas Swagger are the tools used

There was an old standatf called WADL

SDK templates can be generated trough Swagger CodeGen or OpenAPI Generator which are usually suficient for all langauges,
but more power can be extracted trough customizing and creating tempates specific to your needs

boilerplate code and stubs can be autogenerated trough OpenAPI definitions,
there is also the possiblity such as using OpenAPI definitions during runtime to act as a router (Having API Operation map to classes and methods in code)
or as a validation layer(where incoming requests will fail validation unless they conform to the OpenAPI definition's schema) these are used more
commonly in microservice-oriented architectures

API design is done trough Agile or other fast acting methods, but longetivity should be standard, Design is more important when making multiple API'safer
as consistency plays an important rule when making multiple API's

OpenApi makes the minimal upfront cost of describing it worth it, trough the automation that is available


2
==================================

low level tools exist for REST API = telnet for HTTP and OpenSSL for HTTPS

Method  URI      Query            params Body
GET     /reviews maxRating (1-5)  N/A


the URI will be placed after the whole URL
e.g:

https:/ /farmstall.designapis.com/v1/reviews

if we add the query parameter we get

https:/ /farmstall.designapis.com/v1/reviews?maxRating=5

GET methods can have body's like POST's but with a size limit, and binary data can't be send

body also allows encryption, a query has the chance that the data would be logged by servers and proxies between your client and server

%20 is URL encoding for spaces

there are two utilities you can use to opena TCP connection (a pipe you can read data from and write into it)
telnet is available on most systems, OpenSSL is on Unix systems only, the following commands are only used on the Unix systems

$ telnet farmstall.designapis.com 80
# Or for HTTPS sites...
$ openssl s_client -quiet -connect farmstall.designapis.com:443

after which the headers are filled in as follows in the headers

Image 2 - 3.png

The above is a GET request, 
POSTS are done as show in the image below

Image 2 - 4.png


3
===============================

When we turn a API into computer readable data we call it a definition e.g YAML,JSON

Image 2 - 5.png

OpenAPI can use both JSON and YAML, but YAML is easier to handwrite

YAML is a superset of JSON because of the use of flow types [],{}
this makes all JSON documents viable YAML types

Image 2 - 6.png

YAML has more advanced features in comparison with JSON, like advanced/custom data types, anchors, etc.

the following image shows not everything has to be filled in, it shows a Request which we know is a GET method with /reviews as context,
and it returns a list of reviews

Image 2 - 7.png

to describe a query parameter which takes the numbers 1-5 we write the following

Image 2 - 8.png

 https://editor.swagger.io/ is a tool we can write our OpenAPI definitions in


 the minimal workable OpenAPI definition has the following :
  - The OpenAPI Identifier and the version
  - the info object with the title and version fields
  - an empty paths object

Image 2 - 9.png

adding a GET to the path as shown below in the image

Image 2 - 10.png

you can add a server field by using
- url: https://farmstall.designapis.com/v1

Image 2 - 11.png


JSON schema is a specification for descrbining JSON Data

OpenAPI 3.0.x supports JSON Schema draft 04 while OpenAPI 3.1+ supports JSON Schema 2020

this schema can be applied to the response to add a response structure to follow, show below

Image 2 - 12.png

{
 "rating": 3
}

can be written in the JSON Schema fragment

type: object
properties:
 rating:
 type: integer
 minimum: 1
 maximum: 5

an object can have the proprties keyword attached to define a property

extra fields are fine by default it can be changed
e.g 

JSON                        Valid     Description
{ "rating": "hi" }          Invalid   Expected a number but found a string.
{ "rating": 100 }           Valid     100 is a valid number.
{ "rating": 100, "a": "b" } Valid     Extra fields are fine (by default)

limits can be set like a minimum and maximum number aswell as numbers with decimals written as decimals or whole numbers as integer

Range   Category      Notes
1xx     Informational The most common is when a websocket connection is upgraded.
2xx     Success       This indicates some form of success, like the general 200 or the 201 for “created.”
3xx     Redirects     The resource has a different location/URI.
4xx     Client error  The client did something wrong, like misspell a resource or provide invalid details.
5xx     Server error  The server hit an error that isn’t a fault of the client.

MIME/media types are the following

Media type       Description
text/html        The HTML you get back from a web server
text/csv         Comma-separated values
image/png        PNG encoded image
application/json JSON data
application/xml  XML data

You may find suffixes in some media types that indicate a wrapper format. For example,
the SVG media type used for scalable images has the media type of image/svg+xml,
which has the suffix +xml. This indicates that the format is XML but that it will be compliant with the SVG schema.
Occasionally API designers will use custom (or vendor) media types to version the
API. These vendor extensions can also make use of a suffix to indicate the wrapper
format. An example of this in the wild is application/vnd.github.v3+json, which
is for version 3 of GitHub’s public API. You’ll note that it uses JSON as a wrapper
format. Y

uuid follows the regex pattern '^[0-9a-fA-F\-]{36}$' 

openAPI uses the regex syntax of Javascript also called ECMAScript

Image 2 - 13.png

multiple types like this
type: [ number, string, null ] 
are only allowed in JSON Schema not in OpenAPI

to make a type nullable set the following 
type: string 
nullable: true

an array can be set trough the items property

type: array
 items:
  type: object
  properties:
   rating:
   type: integer
   minimum: 1
   maximum: 5


request and response added

Image 2 - 14.png
Image 2 - 15.png

there can be only one RequestBody per operation, but each media type can describeits own 
shape and each shape can be made to fit many different bodies

only some operations are allowed to have request bodies, notable ones which restrict
this are GET and DELETE,

Image 2 - 16.png

traling comma's are only alowed when the item is a field or array item, that
isn't the last item

examples can be given

Image 2 - 17.png

path parameters are the variables used in url's
like GET/Reviews/{reviewId}

path parameters have the following required properties
 - name
 - in = location i.e, query, path, header and cookie
 - schema

parameters can also include the following properties
 - required = required or not this parameter is always required for path parameters
 - example
 - deprecated
 - style = how the value will be serialized
 - explode = whether or not to create a seperate instance for each value in arrays and objects
 - allowreserved = whether or not to allow reserved characters i.e / and ?
   usefull for catchall parameters

Image 2 - 18.png


image showing security implementation
Image 2 - 19.png

password and username implementation

Image 2 - 20.png

Authorization is done as the following

Image 2 - 21.png

OpenAPI supports four categories of security
 - apiKey
  - in: header
  - in: query
  - in: cookie
 - http
  - scheme:
 - oauth2
  - flows: {}
 - openIdConnect
  - openIdConnectUrl: <url>

openapi: 3.0.0
# ...
paths:
 # ...
 /reviews:
 post:
 # ...
  security: 
   - MyUserToken: [] 

on top of the arrangement we will use the security parameter
this has an empty array which normally would have a list of scopes that apply
within the security scheme, this is not used with apiKey types only with oauth2

to add the optional security option do the following
openapi: 3.0.3
# ...
paths:
 # ...
  /reviews:
  post:
   # ...
   security: 
    - {} 
    - MyUserToken: []

in here the empty brackets mean that security is optional 

- http—The http type is for the HTTP Basic authentication scheme, which
describes how to send a username and password through the Authorization
HTTP header. It is specified in RFC 7617 (https://datatracker.ietf.org/doc/
html/rfc7617). Just like apiKey, http doesn’t use scopes.

- oauth2—The oauth2 type is for the OAuth 2.0 protocol, which describes a process for delegated authentication. If you’ve ever been to a website and they
asked you to log in with a third-party account (like Google or Facebook), you’ve
experienced what’s often called the “OAuth dance.” And if the third-party
account asked you which information you wanted to share (such as your name
and email), those are the scopes that the API providers allow the API consumer
to access. You can think of scopes as capabilities that are granted to a user of an
API. After “dancing” between two websites, the API provider hands out a bearer
access token that the API consumer can send through the Authorization
HTTP header. OAuth is specified in RFC 6749 (https://datatracker.ietf.org/
doc/html/rfc6749), and there’s also a great website at https://oauth.net/ that
can help you get started with the protocol.

- openIdConnect—The openIdConnect type is for the OpenID Connect protocol,
which itself is an extension of OAuth 2.0, that adds things like automated discovery and standardized endpoints to get user details. You can learn more
about OpenAPI Connect on its website: https://openid.net/connect/.



Image 2 - 22.png

you can tag API's by Category

all metadata options there are 

Image 2 - 23.png

CommonMark is the markdown type which is made use of in OpenAPI

an example of markdown is at https://github.com/designapis/openapi/blob/main/ch08/02.yml

how to add tags 

Image 2 - 24.png

html of swaggerUI

Image 2 - 25.png


2
================

Domain modeling is the process of taking a problem domain (or area of interest) and
creating a description that can be implemented in computer software.

To create a domain model, we map concepts from the real world onto an
abstract representation. We refer to this representation as a model, while being fully
aware that this creates some ambiguity—the term “model” can refer to the representation of a single concept (for example, the “Dog” model) or of the whole area of
interest (the domain model)

You can
think of the concept as the thing in the real world and the model as the thing
we’ll have on paper

r. Attributes are data that describes the concept, such as a name, and
actions are things that the concept can do or things a user can do with the concept

Image 2 - 26.png

An API, however, is more akin to the view layer of an application. It is a clearly
defined boundary between parts of a system, and it can potentially act as an abstraction layer and hide underlying complexity. An API designer should always look at the
API from the perspective of the client and not the server.

you’ll have classes in your application layer, and you’ll have tables in your database. And depending on how the
application is built, there will either be a manual translation between them or an
automated system called an object-relational mapper (ORM). The API can be considered a third layer with its own domain model.

without consciously knowing it, you already created a representation of this domain
model in OpenAPI, using JSON Schema for attributes and API paths for actions.

we’ve already talked
about two types of users: pet owners and pet sitters. Our model needs to accommodate that by including a role attribute.

user stories can be written as, As a <role> I can <capability>, so that <receive benefit>.
to gain insights0

for user stoeries that depend on other stories, we can use this template:

Given <prerequisite>, I can <capability>.

components can store element definements, it can have a schema sub element like

openapi: 3.0.3
info:
 title: PetSitter API
 version: "0.1"
paths: {}
components:
 schemas: {}

 it can be accessed by the $ref command i.e:
 $ref: '#/components/schemas/User'

JSON name conventions should be followed which mean lowercase and without spaces

schema names typically start with an uppercase letter

a user made inside a schema goes as the following

Image 2 - 27.png


when there is a dependency, this is done by the following

Image 2 - 28.png


it is also possible to do this trough the id's shown below

Image 2 - 29.png

there are two (three but this will be shown later) endpoints:
- Resource endpoint
- Collection endpoint

Resources are indiviudal instances of a concept in the domain model e.g a job
or a user

use plurals for storage of multiple models like
/users/123

this is also called a resource endpoint

when you ask for a collection done like this
/users

this is called a collection endpoint

it is possible to limit the items we get trough paginiation(will get later on it)
and filters like the rating limit

it's also common to use the collection endpoint URL combined with the HTTP POST
method to create a new element for which the ID is not yet known because it is assigned by the server

Operation   Method       Typical    path
Create      POST         Collection endpoint (/{schema}s)
Read        GET          Both       collection and resource endpoints
Update      PUT or PATCH Resource   endpoint (/{schema}s/{id})
Delete      DELETE       Resource   endpoint (/{schema}s/{id})

For “Read” and “Delete” operations, there is no request body. If necessary, the input
for “Read” operations, such as filter criteria, typically goes in query parameters.
 For “Create” and “Update” operations, you need to send the JSON representation
of the resource (a JSON structure following the schema) as the request body.

For “Read” operations on resource endpoints, the response is a JSON object following
the schema of the resource. A successful API call gets status code 200 OK. If the
requested resource does not exist, the API should return a 404 Not Found.
 For “Read” operations on collection endpoints, the response is a collection object
that contains an array of resource objects, optionally accompanied by additional fields
with metadata. The field that contains the array of items is often called items or the
name of the resource. Let’s look at an example of a response structure

Image 2 - 30.png

 A successful deletion
request returns a 204 No Content status code, because 200 expects a response body.

For “Create” operations, which are POST requests on the collection endpoint, the
response body is typically empty. Instead, the response contains a Location header
that points to the resource endpoint for the newly created resource. A successful creation request returns a 201 Created status code

representation = account

Image 2 - 31.png

All CRUD implementations in YAML

Image 2 - 32.png
 
POST is done as follows

Image 2 - 33.png

For “Create” operations, which are POST requests on the collection endpoint, the
response body is typically empty. Instead, the response contains a Location header
that points to the resource endpoint for the newly created resource.

API Design-First approach is also called the contract-first approach

for the front end there are three options to mock data to win time 
as the backend usually needs to be finished to work with it

- Mock on the view layer fast but messie
- mock in a central data store , Redux RxJS etc. is clean tradeoff is mock data is still n the source file
- set up a mock API Server like Prism cleanest and least code changes needed due to switch, tradeoff is that data has no logic

Prism creates mockdata dependant on the OpenAPI definitions

Media Type Object is the formal name for a segment of an OpenAPI definition
that describes the content of a request or response body

Image 2 - 34.png

Prism allows you to send options via the Prefer request header, which gives
you the option to showcase the example code and example data
to start Prism insert the following command  prism mock -p 8080 ./tiny.yml

Image 2 - 35.png

the result should look like this 
$ prism mock -p 8080 ./tiny.yml
[CLI] ... awaiting Starting Prism...
[CLI] i info GET http:/ /127.0.0.1:8080/foo
[CLI] > start Prism is listening on http:/ /127.0.0.1:8080

to showcase the 404 code we will insert it into the prefer header in a openIdConnectUrl
curl -H "Prefer: code=404" http:/ /localhost:8080/foo 
# Gives us...
{"msg":"I am an error example"}

to choose an example the following should be put in the prefer header

curl -H "Prefer: code=200,example=one" http:/ /localhost:8080/foo
# Gives us...
{"foo": 1}

curl -H "Prefer: code=200,example=two" http:/ /localhost:8080/foo
# Gives us...
{"foo": 2}

Swagger CodeGen takes an OpenAPI file as its input and then generates code in various programming languages as its output
in client and server code generation

client code generated by codegen is a type of SDK, in context of API's an SDK
is a library that wraps an API so that developers creating an
application that integrates the API don’t have to build their API calls as HTTP
requests. Instead, developers can call an SDK method that almost looks like a method
in the standard library of their programming language, and the SDK converts that
into an HTTP request. Codegen automates writing the code that does this conversion.
You give it your OpenAPI file, and it will provide you with a complete library to integrate into your application for interacting with the API.

In
programming, a stub is an incomplete method. It already has the interface of the final
method, but it doesn’t yet perform the full functionality. Instead, it returns “mock” or
“dummy” data. 

Unlike client code generation, server code generation with Codegen doesn’t generate a library but rather a draft version of the structure of a server implementation,
with lots of blanks to fill. It’s a starting point for developers, or a template, if you will

1 Open your OpenAPI file in Swagger Editor.
2 Click Generate Server in the menu bar. Swagger Editor will show the backend
technologies for which it can build code.
3 Click nodejs-server. Within seconds, your browser will prompt you to download
a zip file.
4 Save the file on your drive.
5 Extract the zip file into a directory.
6 Open the directory in a code editor or IDE, such as Visual Studio code

when openapi CodeGen is executed use the,
Open openapi.yaml in the api directory and have a look at the first path definition.
There are two new keywords that we should pay attention to:
operationId—There is an operationId for each operation. For the first (with
summary set to Register User) it is usersPOST, a name that Codegen selected by
combining the path (/users) with the HTTP method (POST). If you look at the
controllers/Default.js and service/DefaultService.js files, you’ll notice that this
is the function name for the controller that handles the API operation.
x-swagger-router-controller—The x-swagger-router-controller keyword
is set to Default. As you’ve seen before, Default is the name for the controller
and the service that contains the implementation of the function identified by
the operationId

 Here are the rules that we use:
- Start the operation ID with the action name from the domain model, followed
by the schema name—singular for resource endpoints and plural for collection
endpoints.
- Suffix the name for resource endpoints with WithId, which is a reference to the
path parameter.
- For subresource endpoints, use the following structure: action name, subresource name, For, parent resource name (leave out WithId to shorten the
name).

Method   Path                        Operation ID
POST     /users                      registerUser
GET      /users/{id}                 viewUserWithId
PUT      /users/{id}                 modifyUserWithId
DELETE   /users/{id}                 deleteUserWithId
POST     /jobs                       createJob
GET      /jobs                       listAllJobs
GET      /jobs/{id}                  viewJobWithId
PUT      /jobs/{id}                  modifyJobWithId
DELETE   /jobs/{id}                  deleteJobWithId
GET      /jobs/{id}/job-applications viewApplicationsForJob
POST     /jobs/{id}/job-applications createJobApplication
GET      /users/{id}/jobs            listJobsForUser
PUT      /job-applications/{id}      modifyJobApplicationWithId

You can specify your operation IDs by adding an attribute with the operationId
keyword to your operation’s definition, as shown in the following example for
registerUser.

Image 2 - 36.png

intializing tags  

Image 2 - 37.png

assigning tag

Image 2 - 38.png

o go, as it required the same dependencies.
 To run the backend, open the console or terminal and change the working directory to the one containing the generated Node.js project from Codegen. Then type
the following command:
npm start

If, by any chance, you see npm ERR! Invalid version: "0.1", edit the package.json file
and change the version from 0.1 to 0.1.0. Node.js requires semantic versioning—a
version number with three segments (major, minor, and patch). After changing the
file, run the command again

You can run Prism in proxy mode with the following command:
prism proxy -p 8081 api/openapi.yaml http:/ /localhost:8080

The first parameter (-p) indicates the port for the proxy, the second parameter points
to the location of the OpenAPI file, and the third parameter specifies the URL

to make docker run mongodb image do the following docker 
run --name petsitter-db -d -p 27017:27017 mongo:latest

You can add Mongoose to your project by using npm with the following command:
npm install mongoose --save
You’ll also have to load the library and initialize the database connection in index.js.
To do so, add the following lines in the top part of the file.

const databaseUrl = 'mongodb:/ /127.0.0.1/petsitter_db'; 
const mongoose = require('mongoose');
mongoose.connect(databaseUrl, {
 useNewUrlParser: true,
 useUnifiedTopology: true
});

MongoDB stores data in documents, and every document belongs to a collection.
To represent a domain model in MongoDB, we can use the following approach:
 For every schema, there is a collection.
 For each resource—each instance of a schema—there is a document in the
respective collection.

n fact, Mongoose follows this approach already. We create Mongoose models from
the schemas we have, and Mongoose creates a MongoDB collection for each model

Image 2 - 39.png

There is no id field in the Mongoose model. The reason for that is that
MongoDB implicitly adds a field called _id to each document so we don’t have
to define it

Mongoose allows developers to add custom functions to the models they create by
attaching them to the methods field. Let’s create a function called toResultFormat()
that returns the external format.
Image 2 - 40.png

inline data should be written as follows
Image 2 - 41.png

we’ll also define a toResultFormat() function that converts from the internal to the external format.

Image 2 - 42.png

CodeGen controller standard code

Image 2 - 43.png

CodeGen generated service code

Image 2 - 44.png

We don’t want to return mock data anymore but rather return a real job from our
database. Before we can write database logic, we need to load the database Jobs model
by including the following lines in the head of our services file

const mongoose = require(mongoose');
const JobModel = mongoose.model('Job', require('../models/Job').Job)

updated service code

Image 2 - 45.png

- Some URL paths point to real file paths for static assets, such as images, external stylesheets, and JavaScript files. For example, if the base URL is https://
example.com/ and the application contains an images/logo.png file, the browser
can retrieve it from https://example.com/images/logo.png.
- Some paths are for different pages in a web application that contain dynamic
content but are not individual files. The web application has a router component that handles these URLs. In a traditional web application, the router is
part of the server-side code that dynamically generates the HTML pages. For a
single-page-application (SPA), the server returns the same file—usually named
index.html—for all URLs, and a client-side router handles page generation.

Session security schem

Image 2 - 46.png

Session Schema

Image 2 - 47.png

integrated login feature

Image 2 - 48.png

A global security declaration looks like an operation-specific security declaration.
It even uses the same keyword, security, but the declaration sits at the highest level in
the YAML hierarchy of the OpenAPI definition instead. We can add it to the end of
the file

openapi: 3.0.3
#...
security: 
 - SessionToken: [] 

 If we want to remove the security requirements from an operation, we have to use the
security keyword in a slightly different way. Instead of adding a list of requirements
below it, we have to explicitly set its value to an empty array ([]). Let’s do this for the
two operations that need it

Image 2 - 49.png

OAS
tools do not themselves validate API keys, tokens, or passwords; they just check for
their presence according to the API definition.

With a prefix we’d use
/api/jobs/{id} for the API endpoint, allowing the frontend developer to use
/jobs/{id} for the respective page.

A reverse proxy is a web server that accepts incoming
requests and forwards them to different servers behind it. It is possible to configure
many web servers, such as Apache or NGINX, as reverse proxies with specific configuration rules (a particular type of reverse proxy for APIs is called an API gateway)

The oas3-tools library looks at the servers element in the OpenAPI file to find a
prefix. If you open the api/openapi.yaml file, you’ll see a single server with its url set
to just a slash (/):
servers:
- url: /
We can change that URL to the desired prefix:
servers:
- url: /ap

As we mentioned before, an SPA often has two kinds of URL paths, and that applies to
the PetSitter frontend as well. The first kind points to real static files, and the second
kind points to application pages that all map to the entry file of the application,
index.html.
 Supporting the first kind doesn’t take much effort. Express has the express.static
built-in middleware function, which automatically adds all static files in a given directory as routes to the API. We can use the middleware on the root path for the hostname (/) so that both the starting page and the static files are served, and the routes
defined by the API still work. Also, we can create a rule for every path starting with
/app and map it to the index.html file using Express’s sendFile() function. Note
that, unlike for the API, this setup did not magically move the routes under /app; Max
had already implemented the frontend that way.
 The following code listing shows the two rules in the context of the app initialization code in the index.js file

Image 2 - 50.png

After adding this code and restarting the API server with npm start, opening http:/ /
localhost:8080/ will serve the frontend. You can confirm that Swagger UI still exists at
http:/ /localhost:8080/docs/ and now references the API at /api.

A breaking change in an API is anything that requires consumers of that API to change their integration, because otherwise it will no longer
work.

Postel’s Law, also known as the robustness principle: “Be liberal
in what you accept, and conservative in what you send.”

The second principle is Hyrum’s Law, which is the observation that any observed
or accepted behavior of the system will be the de facto contract, and someone will probably depend on it

There are four relevant OpenAPI keywords for inheritance, also known as composition
keywords. They are allOf, oneOf, anyOf, and not. Let’s look at their definitions:
- allOf—Indicates that a schema is a composition of multiple other schemas,
which means that it has all the attributes from those schemas. If we checked a
JSON object against a schema with allOf, it would only be valid if it passed the
check against all schemas.
- oneOf—Indicates that a schema is one of multiple alternative schemas, which
means that it has the attributes of exactly one of those schemas. If we check a
JSON object against a schema with oneOf, it would only be valid if it passed the
check against just one of those schemas, not multiple schemas (and obviously
not zero).
- anyOf—Indicates that a schema is a combination of multiple schemas, which
means it can have attributes from any of those schemas. If we checked a JSON
Table 16.3 The Cat field and its type
Field Type
breed string
Listing 16.5 PetSitter OpenAPI Cat schema
object against a schema with anyOf, it would be valid as soon as it passed the
check against at least one of the others.
- not—Indicates the inverse. With not, we can confirm that a JSON value isn’t
valid against a schema

use of polymorphism in OpenAPI

Image 2 - 51.png

- With allOf, we could say that a dog is a composition of all the Pet properties
and the specific Dog properties, which would be correct.
- With oneOf, we could say that a pet should either be represented by the Cat
schema or the Dog schema, which is also correct and indicates the reverse of
the previous statement.
- With anyOf, we could say something along the lines that pets have any combination of Cat and Dog properties, which doesn’t make sense (unless you are a scientist working on the genetic modification of pets).
- With not, we could say, for example, that a Dog is not a Cat and vice versa.
While that is technically true, it doesn’t help us express the Pet-to-Dog and Petto-Cat relationships.

outer and innercomposition

Image 2 - 52.png

but OpenAPI knows nothing about the semantics of the species
property. That means it would technically be valid to create the following object:

{
 "name" : "Fluffy",
 "species" : "Cat",
 "age" : 5,
 "breed" : "Border Collie",
 "size" : "50 cm"
}

Luckily the creators of OpenAPI added an additional keyword to the specification that
helps in this type of situation.
It’s called discriminator, and its purpose is to define a
property whose value indicates a schema to select.

You need to add the discriminator keyword next to the oneOf keyword on the
same level in the YAML file

The prerequisite for using discriminators is that all the
entries inside that oneOf must be references and not inline schemas, because they
need to have a name that identifies them, and inline schemas don’t have those. The
discriminator definition is an object with two other keywords, propertyName and
mapping:
 With propertyName you specify the name of the property that points to the
respective schema. It must be a string property that exists in each of the
schemas. We’ll show you shortly how that is done.
 The mapping keyword describes which value of that property corresponds to
which referenced schema. For example, it can connect the string “Cat” with the
Cat schema. There is an implicit mapping that automatically connects the
string with a schema whose name is identical to the value of the property in a
JSON object (e.g., “Cat” with the Cat schema, “Dog” with the Dog schema), but
we recommend making things explicit

Image 2 - 53.png

By default, properties in JSON objects are optional. To make them mandatory, you
can use the required keyword to list a number of properties that a JSON object must
have in order to be valid against the schema

Image 2 - 54.png

- Filters reduce the full dataset to
a subset.
- Sorting puts that subset in a
specifically ordered collection.
- Pagination returns a section of
that ordered collection

gn filters.
 First of all, let’s consider two types of filters. The primary type we’re looking at is a
selection filter, which means it selects a subset of resources from a collection. In the
FarmStall API, that would be all reviews with specific ratings. There’s another type of
filter, called a projection filter, that selects a subset of fields to specify what’s shown for
each resource—it doesn’t affect which resources the API returns. It allows API consumers to say that they’re only interested in some fields for the resources in the collection. For example, imagine you have an API for an online shop with a Customer
schema. The Customer schema most likely contains the full postal address of the customer, so that you can ship goods to them. However, email marketing software as an
API consumer would not be interested in a postal address. It just needs the customer’s
name and email address. This would be a use case for projection filters

In a projection filter To receive data from all customers but only
their names and emails, the API consumer could request GET /customers?fields=
name,email

single acceptable value, or a range of acceptable values. We can formulate ranges in
different ways:
- For any data type—An enumeration of acceptable values
- For numbers—Exact matches (=), less than (<), greater than (>), less than or
equal (< =), greater than or equal (> =), between
- For strings of text—Exact matches, case-insensitive matches, text starting with,
text ending with, text containing

With the square bracket style, suffixes should be part of the inner field name and not
appear at the end. For example, the parameter should be address[zip_code.gte],
not address[zip_code].gte

We’d
consider the following all good options for a country filter:
- addresses.country
- addresses[][country]
- addresses[country]

subresource collection = filtered collection

Apart from adding type: object, however, we also have to specify how we want the
object serialized into key/value pairs. For this purpose, there’s the style keyword,
and by default OpenAPI assumes the form style. This style flattens the object, which
means that the query parameter is called, for example, age_below. If we want to make
sure the object converts its properties to something like pets[age_below], we have to
add style: deepObject to it.

Image 2 - 55.png

Here’s an example of a request that combines some of the filters we’ve added, imagining a potential pet sitter who would like to look after a cat sometime in July 2022:
curl -H "Authorization: {Auth}" "https:/ /petsitter.designapis.com/jobs \
 ?start_time_after=2022-07-01T00:00:00+00:00 \
 &end_time_before=2022-07-31T00:00:00+00:00&pets[species]=Cat

 APIs with offset-based or page-based pagination (this discussion of offset-based
applies to page-based as well) accept two common query parameters for their collection endpoints:
- The first parameter indicates the maximum number of results to return. Typically this is called limit or per_page. It’s common to make the parameter
optional and set a default value in its absence. There should also be a maximum
limit that the API is willing to serve in a single request.
- The second parameter indicates either the number of results (offset-based) or
the number of pages (page-based), starting from the beginning, to skip before
returning any. In the former case it’s generally called offset, and in the second
case it’s often called page. If you omit this parameter, the offset is 0, meaning
results are returned from the beginning.

 Assume you have 40 potential results in a collection. Calling the collection endpoint with limit=20 (or per_page=20, depending on the name used in the API)
would return the first page with resources 1 to 20. To get resources 21 to 40, you’d call
the API with limit=20&offset=20 for resource offsets or limit=20&page=2 for pagebased pagination

total results based pagination
{
 "items": [
 {
 //... 
 }
 ],
 "total_results" : 20
}

cursor based pagination

{
 "items": [
 {
 // item 30
 },
 ...
 {
 // item 21
 }
 ],
 "cursor" : "abcd"
}

OData has a so-called “next link” in each API response that describes
how to make the request for more data. JSON:API suggests providing links for
next, previous, first, and last to allow API clients to move between pages

cursor pagination input

Image 2 - 56.png

pagination response

Image 2 - 57.png

As we’ve mentioned before, API consumers can combine filters and pagination. Let’s
take the sample request and add a limit parameter:
curl -H "Authorization: {Auth}" "https:/ /petsitter.designapis.com/jobs \
 ?start_time_after=2022-07-01T00:00:00+00:00 \
 &end_time_before=2022-07-31T00:00:00+00:00&pets[species]=Cat&limit=10"
This time, the result also includes a cursor:
{
 "items" : [
 //...
 ],
 "cursor" : "507f1f77bcf86cd799439011"
}
With that cursor, the API consumer can make a subsequent request:
curl -H "Authorization: {Auth}" "https:/ /petsitter.designapis.com/jobs \
 ?start_time_after=2022-07-01T00:00:00+00:00 \
 &end_time_before=2022-07-31T00:00:00+00:00&pets[species]=Cat \
 &limit=10&cursor=507f1f77bcf86cd799439011"

 how to implement sorting truogh url

- sort_by=name:asc, sort_by=name:desc
- sort=+created_at, sort=-created_at
Another option is to separate field and direction into two different parameters,
removing the need for a separator character (like “:”):
- sort_by=name&order_by=asc, sort_by=name&order_by=desc

There may also be a requirement to use multiple sort parameters. For instance, if you
have a database of contacts, you may want to sort them by the city they live in, and
within a city you might also want to sort them alphabetically by name. If you need to
support this kind of behavior, you’ll require another separator character (like “,”).
Then, your API could look like this:
sort_by=city:asc,name:asc

OData and JSON:API also use a single parameter. OData calls it
$orderby and JSON:API uses sort. Both specifications support sorting with
multiple fields (comma-separated) as well. OData requires the Asc or Desc
suffix for field names. JSON:API makes ascending the default and asks for a
minus (“-”) as the prefix if the order should be descending

adding sort parameter 

Image 2 - 58.png

curling a sorting query

curl -H "Authorization: {Auth}" "https:/ /petsitter.designapis.com/jobs \
 ?start_time_after=2022-07-01T00:00:00+00:00 \
 &end_time_before=2022-07-31T00:00:00+00:00&pets[species]=Cat&limit=10 \
 &sort=end_time:desc"

 The specification suggests setting
the Content-Type to application/problem+json instead of application/json for
error responses as an additional indicator that it’s an error response and that it’s following a specified standard
problem+json contains the following fields

Field    Type    Description
type     string  A URI describing the type of the error
title    string  A short, human-readable title for the error
status   integer The HTTP status code
detail   string  A human-readable longer explanation of the error
instance string  A URI identifying the occurrence of the proble

error objects created

Image 2 - 59.png

error objects implemented

Image 2 - 60.png